[{"title":"CSRF攻击原理与防御策略深度剖析","tags":["Web","安全","CSRF","系统设计"],"categories":["认证授权"],"author":"Katyusha0x26d","excerpt":"\nCSRF（Cross-Site Request Forgery，跨站请求伪造）是Web应用中一种常见的安全漏洞，攻击者通过伪造用户请求来执行未经授权的操作。本文将详细剖析CSRF攻击的原理、案例，并提供多种防御策略的实现方案。\n\n","link":"/posts/csrf-attack-defense","content":"\nCSRF（Cross-Site Request Forgery，跨站请求伪造）是Web应用中一种常见的安全漏洞，攻击者通过伪造用户请求来执行未经授权的操作。本文将详细剖析CSRF攻击的原理、案例，并提供多种防御策略的实现方案。\n\n<!-- more -->\n\n## CSRF攻击原理\n\nCSRF攻击的核心在于利用浏览器自动携带Cookie的特性。当用户在A网站登录后，浏览器会保存A网站的会话Cookie，此时如果用户访问恶意网站B，B网站可以构造向A网站发送的请求，浏览器会自动带上A网站的Cookie，从而实现以用户身份执行操作。\n\n### 攻击流程示例\n\n假设某银行网站的转账接口如下：\n\n```http\nPOST /transfer HTTP/1.1\nHost: bank.example.com\nCookie: session=abc123\n\namount=1000&to=attacker\n```\n\n攻击流程：\n\n1. 用户登录银行网站，获得会话Cookie\n2. 用户访问恶意网站evil.com\n3. evil.com页面包含如下代码：\n\n```html\n<form id=\"csrf-form\" action=\"https://bank.example.com/transfer\" method=\"POST\">\n    <input type=\"hidden\" name=\"amount\" value=\"10000\">\n    <input type=\"hidden\" name=\"to\" value=\"attacker-account\">\n</form>\n<script>\n    document.getElementById('csrf-form').submit();\n</script>\n```\n\n4. 表单自动提交，浏览器自动带上银行网站的Cookie\n5. 银行服务器验证Cookie有效，执行转账操作\n\n## 典型CSRF攻击场景\n\n### GET请求型CSRF\n\n最简单的CSRF攻击形式，通过图片标签、链接等发起GET请求：\n\n```html\n<!-- 恶意网站中的代码 -->\n<img src=\"https://bank.example.com/transfer?amount=1000&to=attacker\" />\n```\n\n用户浏览恶意页面时，浏览器会自动请求该URL，如果银行使用GET请求处理转账（严重的设计缺陷），攻击就会成功。\n\n::: warn\n\n由于在大多数浏览器中，Cookie的SameSite属性设置为Lax，也就是对于POST请求，不会自动携带跨站Cookie，但是在GET请求，浏览器会自动携带跨站Cookie。所以执行类似于表单提交等操作，请不要使用GET请求。\n\n:::\n\n### POST请求型CSRF\n\n通过自动提交的表单发起POST请求，如上面银行转账的例子。更隐蔽的方式是使用iframe：\n\n```html\n<iframe style=\"display:none\" name=\"csrf-frame\"></iframe>\n<form method=\"POST\" action=\"https://victim.com/api/action\" target=\"csrf-frame\" id=\"csrf-form\">\n    <input type=\"hidden\" name=\"action\" value=\"delete_account\">\n</form>\n<script>document.getElementById(\"csrf-form\").submit();</script>\n```\n\n### JSON请求型CSRF\n\n现代Web应用经常使用JSON格式的API，攻击者可以通过特殊构造的表单发送JSON数据：\n\n```html\n<form id=\"csrf-form\" enctype=\"text/plain\" action=\"https://api.example.com/user/delete\" method=\"POST\">\n    <input name='{\"id\":123,\"ignore\":\"' value='\"}'>\n</form>\n```\n\n提交后会发送：`{\"id\":123,\"ignore\":\"=\"}`，某些宽松的JSON解析器可能会接受这种格式。\n\n## CSRF防御策略\n\n### CSRF Token防御\n\n这是最常用也是最有效的防御方式，服务器生成随机token，客户端请求时必须携带正确的token。\n\nSpring Boot实现示例：\n\n```java\n@Component\npublic class CsrfTokenFilter extends OncePerRequestFilter {\n\n    private static final String CSRF_TOKEN_ATTR = \"CSRF_TOKEN\";\n    private static final String CSRF_TOKEN_HEADER = \"X-CSRF-Token\";\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain filterChain) throws ServletException, IOException {\n\n        HttpSession session = request.getSession();\n\n        // GET请求时生成token\n        if (\"GET\".equals(request.getMethod())) {\n            String token = (String) session.getAttribute(CSRF_TOKEN_ATTR);\n            if (token == null) {\n                token = UUID.randomUUID().toString();\n                session.setAttribute(CSRF_TOKEN_ATTR, token);\n            }\n            request.setAttribute(CSRF_TOKEN_ATTR, token);\n        }\n        // POST/PUT/DELETE请求时验证token\n        else if (!\"OPTIONS\".equals(request.getMethod())) {\n            String sessionToken = (String) session.getAttribute(CSRF_TOKEN_ATTR);\n            String requestToken = request.getHeader(CSRF_TOKEN_HEADER);\n\n            if (requestToken == null) {\n                requestToken = request.getParameter(\"_csrf\");\n            }\n\n            if (sessionToken == null || !sessionToken.equals(requestToken)) {\n                response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid CSRF Token\");\n                return;\n            }\n        }\n\n        filterChain.doFilter(request, response);\n    }\n}\n```\n\n前端Vue示例：\n\n```javascript\n// 获取CSRF Token\nasync function getCsrfToken() {\n    const response = await fetch('/api/csrf-token');\n    const data = await response.json();\n    return data.token;\n}\n\n// 发送请求时携带Token\nasync function makeRequest(url, data) {\n    const csrfToken = await getCsrfToken();\n\n    return fetch(url, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'X-CSRF-Token': csrfToken\n        },\n        body: JSON.stringify(data)\n    });\n}\n```\n\n### Double Submit Cookie防御\n\n将CSRF Token同时存储在Cookie和请求参数中，服务器验证两者是否一致：\n\n```java\n@Component\npublic class DoubleSubmitCookieFilter extends OncePerRequestFilter {\n\n    private static final String CSRF_COOKIE_NAME = \"XSRF-TOKEN\";\n    private static final String CSRF_HEADER_NAME = \"X-XSRF-TOKEN\";\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain filterChain) throws ServletException, IOException {\n\n        // 为GET请求设置Cookie\n        if (\"GET\".equals(request.getMethod())) {\n            Cookie[] cookies = request.getCookies();\n            boolean hasToken = false;\n\n            if (cookies != null) {\n                for (Cookie cookie : cookies) {\n                    if (CSRF_COOKIE_NAME.equals(cookie.getName())) {\n                        hasToken = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!hasToken) {\n                String token = UUID.randomUUID().toString();\n                Cookie csrfCookie = new Cookie(CSRF_COOKIE_NAME, token);\n                csrfCookie.setHttpOnly(false); // JavaScript需要读取\n                csrfCookie.setPath(\"/\");\n                response.addCookie(csrfCookie);\n            }\n        }\n        // 验证POST请求\n        else if (!\"OPTIONS\".equals(request.getMethod())) {\n            String cookieToken = null;\n            Cookie[] cookies = request.getCookies();\n\n            if (cookies != null) {\n                for (Cookie cookie : cookies) {\n                    if (CSRF_COOKIE_NAME.equals(cookie.getName())) {\n                        cookieToken = cookie.getValue();\n                        break;\n                    }\n                }\n            }\n\n            String headerToken = request.getHeader(CSRF_HEADER_NAME);\n\n            if (cookieToken == null || !cookieToken.equals(headerToken)) {\n                response.sendError(HttpServletResponse.SC_FORBIDDEN, \"CSRF token validation failed\");\n                return;\n            }\n        }\n\n        filterChain.doFilter(request, response);\n    }\n}\n```\n\n### SameSite Cookie属性\n\n::: info\n\n在早期互联网，CSRF攻击影响深远，但是[从2020年5月，Chrome 80中，Cookie的SameSite属性默认被定义为Lax](https://developers.google.com/search/blog/2020/01/get-ready-for-new-samesitenone-secure?hl=zh-cn)，这一操作解决了绝大多数未经修复的CSRF漏洞\n\n:::\n\n通过设置Cookie的SameSite属性，限制第三方网站携带Cookie：\n\n```java\n@Configuration\npublic class SessionConfig {\n\n    @Bean\n    public ServletContextInitializer servletContextInitializer() {\n        return servletContext -> {\n            SessionCookieConfig sessionCookieConfig = servletContext.getSessionCookieConfig();\n            sessionCookieConfig.setHttpOnly(true);\n            sessionCookieConfig.setSecure(true); // 仅HTTPS\n            // 设置SameSite属性\n            sessionCookieConfig.setComment(\"SameSite=Strict\");\n        };\n    }\n}\n\n// Spring Boot 2.6+ 可以直接配置\n// application.yml\n// server:\n//   servlet:\n//     session:\n//       cookie:\n//         same-site: strict\n```\n\nSameSite有三个值：\n- **Strict**：完全禁止第三方Cookie，跨站点时不会发送Cookie\n- **Lax**：大多数情况不发送，但导航到目标网址的GET请求除外\n- **None**：不限制（需要同时设置Secure属性）\n\n### Referer/Origin验证\n\n验证请求的来源是否合法：\n\n```java\n@Component\npublic class RefererCheckFilter extends OncePerRequestFilter {\n\n    @Value(\"${app.allowed-origins}\")\n    private List<String> allowedOrigins;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain filterChain) throws ServletException, IOException {\n\n        // 仅检查状态改变的请求\n        if (!\"GET\".equals(request.getMethod()) && !\"OPTIONS\".equals(request.getMethod())) {\n            String referer = request.getHeader(\"Referer\");\n            String origin = request.getHeader(\"Origin\");\n\n            boolean isValid = false;\n\n            // 优先检查Origin\n            if (origin != null) {\n                isValid = allowedOrigins.stream().anyMatch(origin::startsWith);\n            }\n            // Origin不存在时检查Referer\n            else if (referer != null) {\n                isValid = allowedOrigins.stream().anyMatch(referer::startsWith);\n            }\n\n            if (!isValid) {\n                response.sendError(HttpServletResponse.SC_FORBIDDEN, \"Invalid request origin\");\n                return;\n            }\n        }\n\n        filterChain.doFilter(request, response);\n    }\n}\n```\n\n### 验证码防御\n\n对于敏感操作，要求用户输入验证码：\n\n```java\n@RestController\n@RequestMapping(\"/api\")\npublic class TransferController {\n\n    @Autowired\n    private CaptchaService captchaService;\n\n    @PostMapping(\"/transfer\")\n    public ResponseEntity<?> transfer(@RequestBody TransferRequest request,\n                                     @RequestParam String captcha,\n                                     HttpSession session) {\n\n        // 验证验证码\n        String sessionCaptcha = (String) session.getAttribute(\"CAPTCHA\");\n        if (sessionCaptcha == null || !sessionCaptcha.equalsIgnoreCase(captcha)) {\n            return ResponseEntity.badRequest().body(\"验证码错误\");\n        }\n\n        // 验证码使用后立即删除\n        session.removeAttribute(\"CAPTCHA\");\n\n        // 执行转账逻辑\n        // ...\n\n        return ResponseEntity.ok(\"转账成功\");\n    }\n\n    @GetMapping(\"/captcha\")\n    public void getCaptcha(HttpServletResponse response, HttpSession session) throws IOException {\n        // 生成验证码\n        String captchaText = captchaService.generateText();\n        BufferedImage captchaImage = captchaService.generateImage(captchaText);\n\n        // 保存到Session\n        session.setAttribute(\"CAPTCHA\", captchaText);\n\n        // 输出图片\n        response.setContentType(\"image/png\");\n        ImageIO.write(captchaImage, \"PNG\", response.getOutputStream());\n    }\n}\n```\n\n### 使用localStorage存储token\n\n常规场景下，会话信息被存储于Cookie，浏览器会自动携带Cookie，但是我们可以将会话信息存储于localStorage中，这样会话不会自动被携带上去。\n\n将会话信息存储于localStorage还有一个好处是，有一些移动端应用，没有完整的Cookie功能，如果使用localStorage就可以弥补这方面的缺陷\n\n## Spring Security集成方案\n\nSpring Security提供了完善的CSRF防护机制：\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            // 启用CSRF保护\n            .csrf(csrf -> csrf\n                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())\n                // 忽略特定路径\n                .ignoringAntMatchers(\"/api/public/**\")\n                // 自定义失败处理\n                .accessDeniedHandler((request, response, ex) -> {\n                    response.setStatus(HttpStatus.FORBIDDEN.value());\n                    response.getWriter().write(\"CSRF Token验证失败\");\n                })\n            )\n            .authorizeHttpRequests(authz -> authz\n                .antMatchers(\"/api/public/**\").permitAll()\n                .anyRequest().authenticated()\n            );\n\n        return http.build();\n    }\n\n    // 自定义Token存储\n    @Bean\n    public CsrfTokenRepository csrfTokenRepository() {\n        HttpSessionCsrfTokenRepository repository = new HttpSessionCsrfTokenRepository();\n        repository.setParameterName(\"_csrf\");\n        repository.setHeaderName(\"X-CSRF-TOKEN\");\n        return repository;\n    }\n}\n```\n\n前端集成：\n\n```javascript\n// 使用axios拦截器自动添加CSRF Token\naxios.interceptors.request.use(config => {\n    // 从Cookie中读取token（Spring Security默认名称）\n    const token = document.cookie\n        .split('; ')\n        .find(row => row.startsWith('XSRF-TOKEN='))\n        ?.split('=')[1];\n\n    if (token) {\n        config.headers['X-XSRF-TOKEN'] = decodeURIComponent(token);\n    }\n\n    return config;\n});\n```\n\n## 测试CSRF防护\n\n编写测试用例验证CSRF防护是否有效：\n\n```java\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class CsrfProtectionTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    @Test\n    public void testWithoutCsrfToken() throws Exception {\n        // 没有CSRF Token的请求应该被拒绝\n        mockMvc.perform(post(\"/api/transfer\")\n                .param(\"amount\", \"1000\")\n                .param(\"to\", \"attacker\"))\n                .andExpect(status().isForbidden());\n    }\n\n    @Test\n    public void testWithValidCsrfToken() throws Exception {\n        // 先获取CSRF Token\n        MvcResult result = mockMvc.perform(get(\"/api/csrf\"))\n                .andExpect(status().isOk())\n                .andReturn();\n\n        String token = result.getResponse().getContentAsString();\n\n        // 使用有效Token的请求应该成功\n        mockMvc.perform(post(\"/api/transfer\")\n                .header(\"X-CSRF-Token\", token)\n                .param(\"amount\", \"1000\")\n                .param(\"to\", \"recipient\"))\n                .andExpect(status().isOk());\n    }\n\n    @Test\n    public void testCsrfTokenReuse() throws Exception {\n        // 获取Token\n        MvcResult result = mockMvc.perform(get(\"/api/csrf\"))\n                .andReturn();\n        String token = result.getResponse().getContentAsString();\n\n        // 第一次使用\n        mockMvc.perform(post(\"/api/sensitive-action\")\n                .header(\"X-CSRF-Token\", token))\n                .andExpect(status().isOk());\n\n        // Token不应该被重复使用（对于一次性Token的情况）\n        mockMvc.perform(post(\"/api/sensitive-action\")\n                .header(\"X-CSRF-Token\", token))\n                .andExpect(status().isForbidden());\n    }\n}\n```\n"},{"title":"DIY一个Markdown页面访问计数器","tags":["Web","DIY","Markdown"],"categories":["项目"],"author":"Katyusha0x26d","excerpt":"\n众所周知，给Markdown页面做访问计数，要么像卜蒜子API这样，直接在显示Markdown的网页上做功夫，要么就是在Markdown中嵌入一张图片，在提供图片的后端进行计数，在图片上显示计数\n\n![效果展示](https://lc-gluttony.s3.amazonaws.com/6Beck3SuJkGW/e5KI7oHaP9A8r41x3FK9XXQQECv5P8LU/Snipaste_2025-07-22_16-56-42.png \"效果展示\")\n\n我的GitHub主页就是这样的计数方式，然而[glitch最近关停了一些托管的应用](https://blog.glitch.com/post/changes-are-coming-to-glitch/)，该计数器就是托管于glitch，并且我也没找到官方仓库，所以便自己用Springboot做了一个类似的东西\n\n","link":"/posts/diy-markdown-visit-counter","content":"\n众所周知，给Markdown页面做访问计数，要么像卜蒜子API这样，直接在显示Markdown的网页上做功夫，要么就是在Markdown中嵌入一张图片，在提供图片的后端进行计数，在图片上显示计数\n\n![效果展示](https://lc-gluttony.s3.amazonaws.com/6Beck3SuJkGW/e5KI7oHaP9A8r41x3FK9XXQQECv5P8LU/Snipaste_2025-07-22_16-56-42.png \"效果展示\")\n\n我的GitHub主页就是这样的计数方式，然而[glitch最近关停了一些托管的应用](https://blog.glitch.com/post/changes-are-coming-to-glitch/)，该计数器就是托管于glitch，并且我也没找到官方仓库，所以便自己用Springboot做了一个类似的东西\n\n<!-- more -->\n\n## 访问计数\n\n上文提到的两种Markdown页面访问计数的方式，很显然，第一种较为麻烦，例如，在Typora中，就算你开发了一个插件，利用卜蒜子API或者其他的服务进行访问计数，那么你该如何比较方便地共享给其他人甚至是使用其他Markdown软件（例如Obsidian）的用户呢？\n\n我的想法就是第二种，在Markdown中嵌入一个图片资源，用户每次预览Markdown，客户端就会访问一次该图片链接，服务器便记录一次访问，同时将访问计数渲染在图片中，返回给客户端\n\n这种处理方式的典型流程如下：\n\n![流程](https://lc-gluttony.s3.amazonaws.com/6Beck3SuJkGW/CffGHCgRtoRY2si8FOU82OVgWCvRo47S/Snipaste_2025-07-22_21-21-43.png \"流程\")\n\n用户访问指定资源的计数器图片时，服务器从`redis`中查询计数，若查询到，自增并将数据处理到图片上，返回给客户端\n\n若服务器在`redis`中查询不到用户计数，先从数据库中读取计数，保存到`redis`并自增\n\n服务器定期将`redis`中的计数同步到数据库中\n\n具体实现如下：\n\n```java\npackage me.katyusha.visitcounter.service;\n\nimport me.katyusha.visitcounter.entity.VisitCount;\nimport me.katyusha.visitcounter.mapper.VisitCountMapper;\nimport org.redisson.api.RLock;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.script.RedisScript;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Service;\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n@Service\npublic class VisitCountService {\n\n    private final VisitCountMapper visitCountMapper;\n    private final RedisTemplate<String, Object> redisTemplate;\n    private final RedisScript<Long> atomicIncrExpireScript;\n    private final RedissonClient redissonClient;\n\n    private static final String REDIS_COUNT_PREFIX = \"count:page:\";\n    private static final String REDIS_LOCK_PREFIX = \"lock:page:\";\n    private static final long REDIS_COUNT_TTL = 60 * 60;\n    private static final long SYNC_INTERVAL = 5 * 60;\n    private static final long LOCK_WAIT_TIME = 3;\n    private static final long LOCK_LEASE_TIME = 5;\n\n    public VisitCountService(VisitCountMapper visitCountMapper, RedisTemplate<String, Object> redisTemplate, RedisScript<Long> atomicIncrExpireScript, RedissonClient redissonClient) {\n        this.visitCountMapper = visitCountMapper;\n        this.redisTemplate = redisTemplate;\n        this.atomicIncrExpireScript = atomicIncrExpireScript;\n        this.redissonClient = redissonClient;\n    }\n\n    private Long atomicIncrExpire(String pageKey, long expiration) {\n        List<String> keys = Collections.singletonList(pageKey);\n        Object[] args = {expiration};\n        Long result = redisTemplate.execute(atomicIncrExpireScript, keys, args);\n        return result == -1 ? null : result;\n    }\n\n    private Long handleFirstVisit(String pageKey) {\n        String redisLockKey = REDIS_LOCK_PREFIX + pageKey;\n        String redisCountKey = REDIS_COUNT_PREFIX + pageKey;\n        RLock lock = redissonClient.getLock(redisLockKey);\n\n        try {\n            // 保证同一时刻同一资源，数据库只能被一个并发流访问\n            if (lock.tryLock(LOCK_WAIT_TIME, LOCK_LEASE_TIME, TimeUnit.SECONDS)) {\n                try {\n                    // 二次验证，如果在之前已有并发流将数据从数据库缓存到redis，那么直接返回自增后的数据\n                    Object cachedCount = redisTemplate.opsForValue().get(redisCountKey);\n                    if (cachedCount != null) {\n                        Long count = ((Number) cachedCount).longValue() + 1;\n                        redisTemplate.opsForValue().set(redisCountKey, count, REDIS_COUNT_TTL, TimeUnit.SECONDS);\n                        return count;\n                    }\n\n                    // 从数据库中查找\n                    VisitCount visitCount = visitCountMapper.findByPageKey(pageKey);\n                    Long count = Optional.ofNullable(visitCount)\n                            .map(VisitCount::getCount)\n                            .orElseGet(() -> {\n                                // 在数据库也找不到，插入新的数据\n                                visitCountMapper.insertZero(pageKey);\n                                return 0L;\n                            });\n\n                    // 保存到redis并自增返回\n                    Long finalCount = count + 1;\n                    redisTemplate.opsForValue().set(redisCountKey, finalCount, REDIS_COUNT_TTL, TimeUnit.SECONDS);\n                    return finalCount;\n                } finally {\n                    lock.unlock();\n                }\n            } else {\n                Thread.sleep(50);\n                // 休息50毫秒后再次尝试获取数据库访问权\n                return handleFirstVisit(pageKey);\n\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n        return 1L;\n    }\n\n    // 计数自增的访问\n    public Long incrementVisit(String pageKey) {\n        String redisCountKey = REDIS_COUNT_PREFIX + pageKey;\n        // 从redis中自增计数，如果找不到键值，返回null\n        Long count = atomicIncrExpire(redisCountKey, REDIS_COUNT_TTL);\n        if (count == null) {\n            // redis中找不到，前往数据库查询\n            return handleFirstVisit(pageKey);\n        }\n        return count;\n    }\n\n    // 定期同步redis到数据库\n    @Scheduled(fixedDelay = SYNC_INTERVAL, timeUnit = TimeUnit.SECONDS)\n    public void syncToDatabase() {\n        String redisAllKey = REDIS_COUNT_PREFIX + \"*\";\n        Set<String> redisKeys = redisTemplate.keys(redisAllKey);\n        List<VisitCount> updateList = new ArrayList<>();\n        for (String redisKey : redisKeys) {\n            Object redisValue = redisTemplate.opsForValue().get(redisKey);\n            if (redisValue != null) {\n                VisitCount visitCount = new VisitCount();\n                visitCount.setPageKey(redisKey.substring(REDIS_COUNT_PREFIX.length()));\n                visitCount.setCount(((Number) redisValue).longValue());\n                updateList.add(visitCount);\n            }\n        }\n        visitCountMapper.batchUpdate(updateList);\n    }\n}\n\n```\n\n数据库建表：\n\n```sql\nDROP TABLE IF EXISTS visit_count;\nCREATE TABLE visit_count (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    page_key VARCHAR(255) NOT NULL,\n    count BIGINT NOT NULL DEFAULT 0,\n    UNIQUE KEY uk_page_key (page_key)\n);\n```\n\n`Mybatis`数据访问层接口：\n\n```java\npackage me.katyusha.visitcounter.mapper;\n\nimport me.katyusha.visitcounter.entity.VisitCount;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.util.List;\n\n@Mapper\npublic interface VisitCountMapper {\n    VisitCount findByPageKey(@Param(\"pageKey\") String pageKey);\n    int insert(@Param(\"visitCount\") VisitCount visitCount);\n    int insertZero(@Param(\"pageKey\") String pageKey);\n    int batchUpdate(List<VisitCount> updateList);\n}\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"me.katyusha.visitcounter.mapper.VisitCountMapper\">\n\n    <resultMap id=\"VisitCountResultMap\" type=\"me.katyusha.visitcounter.entity.VisitCount\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"pageKey\" column=\"page_key\"/>\n        <result property=\"count\" column=\"count\"/>\n    </resultMap>\n\n    <select id=\"findByPageKey\" resultMap=\"VisitCountResultMap\">\n        SELECT * FROM visit_count\n        WHERE page_key = #{pageKey}\n    </select>\n\n    <insert id=\"insert\" keyProperty=\"id\" useGeneratedKeys=\"true\">\n        INSERT INTO visit_count (page_key, count)\n        VALUES (#{visitCount.pageKey}, #{visitCount.count})\n    </insert>\n\n    <insert id=\"insertZero\">\n        INSERT INTO visit_count (page_key, count)\n        VALUES (#{pageKey}, 0)\n    </insert>\n\n    <update id=\"batchUpdate\" parameterType=\"list\">\n        <if test=\"list != null and list.size() > 0\">\n            UPDATE visit_count SET\n            count = CASE page_key\n            <foreach collection=\"list\" item=\"item\">\n                WHEN #{item.pageKey} THEN #{item.count}\n            </foreach>\n            END\n            WHERE page_key IN\n            <foreach collection=\"list\" item=\"item\" open=\"(\" close=\")\" separator=\",\">\n                #{item.pageKey}\n            </foreach>\n        </if>\n    </update>\n\n</mapper>\n\n```\n\n`redis`的原子化判断键值并自增脚本：\n\n```lua\nlocal key = KEYS[1]\nlocal expire_seconds = tonumber(ARGV[1])\n\nif redis.call('EXISTS', key) == 0 then\n    return -1\nelse\n    local new_value = redis.call('INCR', key)\n    redis.call('EXPIRE', key, expire_seconds)\n    return new_value\nend\n\n```\n\n`redis`配置：\n\n```java\npackage me.katyusha.visitcounter.config;\n\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.script.DefaultRedisScript;\nimport org.springframework.data.redis.core.script.RedisScript;\nimport org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\n@EnableCaching\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(connectionFactory);\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());\n        return template;\n    }\n\n    @Bean\n    public RedisScript<Long> incrementAndExpireScript() {\n        DefaultRedisScript<Long> script = new DefaultRedisScript<>();\n        script.setLocation(new ClassPathResource(\"scripts/redis-atomic-incr-expire.lua\"));\n        script.setResultType(Long.class);\n        return script;\n    }\n}\n```\n\n控制器层：\n\n```java\npackage me.katyusha.visitcounter.controller;\n\nimport me.katyusha.visitcounter.service.SVGCounterService;\nimport org.springframework.http.CacheControl;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.concurrent.TimeUnit;\n\n@RestController\n@RequestMapping(\"/count/svg/\")\npublic class SVGCounterController {\n\n    private final SVGCounterService svgCounterService;\n\n    public SVGCounterController(SVGCounterService svgCounterService) {\n        this.svgCounterService = svgCounterService;\n    }\n\n    // 设置返回MimeType，SVG图片为image/svg+xml\n    @GetMapping(value = \"/{pageKey}/{template}.svg\", produces = \"image/svg+xml\")\n    public ResponseEntity<String> getSVGCounter(@PathVariable(\"pageKey\") String pageKey, @PathVariable(\"template\") String template) {\n        return ResponseEntity.ok()\n                // 设置Cache-Control响应头\n                .header(\"Cache-Control\", \"max-age=0, no-cache, no-store, must-revalidate\")\n                .body(svgCounterService.getSVGCounter(pageKey, template));\n    }\n}\n\n```\n\n注意，GitHub等网站会对Markdown文件中的图片进行缓存，所以如果不设置图片的`Cache-Control`响应头，那么再次访问时，GitHub将不再请求源服务器，解决方案是将响应头的`Cache-Control`设置为`max-age=0, no-cache, no-store, must-revalidate`\n\n## 数据显示\n\n一般而言访问计数器的图片结构过于简单，例如我最喜欢的[for-the-badge](https://forthebadge.com/)风格，仅仅定义了两个矩形，并且在矩形上显示几个字\n\n在这种情况下，使用SVG而不是其他格式例如PNG、JPEG拥有以下多个优势：\n\n- 构造简单，只需要规定哪个地方会出现什么文字、什么图形\n\n- 文件极小，质量极高\n\nSVG图像使用XML进行定义，例如一个典型的for-the-badge风格的图像的定义如下所示：\n\n```xml\n<svg xmlns=\"http://www.w3.org/2000/svg\"\n     xmlns:th=\"http://www.thymeleaf.org\"\n     width=\"200\" height=\"30\" viewBox=\"0 0 200 30\">\n    <rect x=\"0%\" y=\"0%\" width=\"50%\" height=\"100%\" fill=\"#21262d\"/>\n    <rect x=\"50%\" y=\"0%\" width=\"50%\" height=\"100%\" fill=\"#161b22\"/>\n    <text x=\"25%\" y=\"50%\" font-size=\"14\" font-family=\"Ubuntu Mono\" fill=\"#7ce38b\" text-anchor=\"middle\" dominant-baseline=\"middle\" font-weight=\"bold\" letter-spacing=\"3\">\n        VISITORS\n    </text>\n    <text x=\"75%\" y=\"50%\" font-size=\"14\" font-family=\"Ubuntu Mono\" fill=\"#7ce38b\" text-anchor=\"middle\" dominant-baseline=\"middle\" font-weight=\"bold\" letter-spacing=\"3\">\n        01234567\n    </text>\n</svg>\n```\n\n在这里我们定义了这张图片由两个`rect`组成，二者占据了画板的左半部分和右半部分，颜色分别为`#21262d`和`#161b22`，有两个`text`，分别为画板的左1/4和右1/4\n\n如果要想在SVG上显示计数也很简单，直接以类似的方式定义一个SVG图片模板，随后在`text`区域使用`thymeleaf`插入一行文本即可\n\n在Springboot中的处理如下所示：\n\n```java\npublic String getSVGCounter(String pageKey, String template) {\n    Long count = visitCountService.incrementVisit(pageKey);\n    Context context = new Context();\n    context.setVariable(\"count\", count);\n    return templateEngine.process(template, context);\n}\n```\n\n同时，`thymeleaf`默认是不支持SVG模板的，所以需要配置一下：\n\n\n```java\n@Configuration\npublic class ThymeleafSVGConfig {\n\n    @Bean\n    public SpringResourceTemplateResolver templateResolver() {\n        SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver();\n        templateResolver.setPrefix(\"classpath:templates/\");\n        templateResolver.setSuffix(\".svg\");\n        templateResolver.setTemplateMode(TemplateMode.XML);\n        templateResolver.setCharacterEncoding(\"UTF-8\");\n        templateResolver.setOrder(1);\n        templateResolver.setCheckExistence(true);\n        return templateResolver;\n    }\n}\n```\n\n配置`thymeleaf`在`classpath:templates`下寻找模板文件，模板以.svg结尾，`templateEngine`在处理时不需要指定文件后缀\n\n## 总结\n\n至此，你便DIY了一个高性能的Markdown访问计数器，如果你用[我的仓库](https://github.com/Katyusha0x26d/VisitCounter)直接部署了一个，那么建议共享出来供大家使用哦！\n"},{"title":"Valaxy测试页","tags":["valaxy","博客"],"categories":["博客"],"author":"Katyusha0x26d","excerpt":"\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n\n## Markdown基本及附加功能测试\n\n这是一段基本Markdown格式的文字，包含","link":"/posts/hello-valaxy","content":"\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n\n## Markdown基本及附加功能测试\n\n这是一段基本Markdown格式的文字，包含**加粗**、*斜体*、***斜体加粗***、<u>HTML下划线</u>[^1]、~~删除线~~^[内联脚注测试]\n\n[^1]: Markdown里并没有内置的下划线支持，对于下划线的实现，需要使用`<u></u>`的HTML标签，详情请见扩展阅读[1]\n\n> 引用部分\n>\n>> 嵌套引用\n>\n> #### 引用内标题\n>\n> 无序列表\n>\n> - First item\n> - Second item\n> - Third item\n>     - Indented item\n>     - Indented item\n> - Fourth item\n>\n> 有序列表\n> 1. First item\n> 2. Second item\n> 3. Third item\n>     1. Indented item\n>     2. Indented item\n> 4. Fourth item\n>\n>  *引用斜体*， **引用加粗**和~~引用删除线~~\n>\n> 引用代码块\n> ```c++{6}\n> #include <bits/stdc++.h>\n>\n> using namespace std;\n>\n> int main(int argc, char **argv) {\n>   cout << \"Hello, valaxy!\" << endl;\n>   return 0;\n> }\n> ```\n\n无序列表\n\n- First item\n- Second item\n- Third item\n    - Indented item\n    - Indented item\n- Fourth item\n\n有序列表\n1. First item\n2. Second item\n3. Third item\n    1. Indented item\n    2. Indented item\n4. Fourth item\n\n代码块\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char **argv) {\n  cout << \"Hello, valaxy!\" << endl;\n  return 0;\n}\n```\n\n代码行高亮\n```c++{6}\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char **argv) {\n  cout << \"Hello, valaxy!\" << endl;\n  return 0;\n}\n```\n\n```js\nexport default {\n  data () {\n    return {\n      msg: 'Removed' // [!code --]\n      msg: 'Added' // [!code ++]\n    }\n  }\n}\n```\n\n```js\nexport default {\n  data () {\n    return {\n      msg: 'Error', // [!code error]\n      msg: 'Warning' // [!code warning]\n    }\n  }\n}\n```\n\n容器\n\n:::\n\n::: tip\n\ntip\n\n:::\n\n::: warning\n\nwarning\n\n:::\n\n::: danger\n\ndanger\n\n:::\n\n::: info\n\ninfo\n\n:::\n\n::: details Click to expand\n\nDetails Content\n\n:::\n\n单行代码`sudo vim /etc/resolv.conf`\n\n超链接 [valaxy](https://valaxy.site/ \"Valaxy official site\")\n\n超链接 *[Katyusha Mindpalace](https://katyusha.me/)*\n\n邮箱 <katyusha0x26d@gmail.com>\n\n图片\n\n![Katyusha avatar](https://katyusha.me/katyusha.jpg \"avatar\")\n\nEmoji :tada:\n\nKatax\n\nWhen $a \\ne 0$, there are two solutions to $(ax^2 + bx + c = 0)$ and they are\n$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} $$\n\n**Maxwell's equations:**\n\n| equation                                                                                                                                                                  | description                                                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |\n| $\\nabla \\cdot \\vec{\\mathbf{B}}  = 0$                                                                                                                                      | divergence of $\\vec{\\mathbf{B}}$ is zero                                               |\n| $\\nabla \\times \\vec{\\mathbf{E}}\\, +\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{B}}}{\\partial t}  = \\vec{\\mathbf{0}}$                                                          | curl of $\\vec{\\mathbf{E}}$ is proportional to the rate of change of $\\vec{\\mathbf{B}}$ |\n| $\\nabla \\times \\vec{\\mathbf{B}} -\\, \\frac1c\\, \\frac{\\partial\\vec{\\mathbf{E}}}{\\partial t} = \\frac{4\\pi}{c}\\vec{\\mathbf{j}}    \\nabla \\cdot \\vec{\\mathbf{E}} = 4 \\pi \\rho$ | _wha?_                                                                                 |\n\nmermaid\n\n```mermaid\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n```\n\nUnoCSS\n\n<div class=\"flex flex-col\">\n\n<div class=\"flex grid-cols-2 justify-center items-center\">\n\n![image](https://cdn.yunyoujun.cn/img/bg/stars-timing-1.jpg)\n\n![image](https://cdn.yunyoujun.cn/img/bg/astronaut.webp)\n\n</div>\n\n</div>\n\n# 扩展阅读\n\n[[1]Markdown教程](https://markdown.com.cn/)\n\n[[2]Markdown Extension - Valaxy](https://valaxy.site/guide/markdown)\n"},{"title":"OAuth2.0协议原理与Spring Security完整实现","tags":["OAuth2.0","Spring Security","认证","系统设计"],"categories":["认证授权"],"author":"Katyusha0x26d","excerpt":"\n最近在开发一个需要第三方登录的Spring Boot项目，需要实现类似“使用GitHub登录”、“使用微信登录”的功能。OAuth2.0作为目前最流行的授权框架，完美解决了第三方授权的问题。本文将从协议规范到代码实现，详细剖析OAuth2.0的工作原理。\n\n","link":"/posts/oauth2-authentication-implementation","content":"\n最近在开发一个需要第三方登录的Spring Boot项目，需要实现类似“使用GitHub登录”、“使用微信登录”的功能。OAuth2.0作为目前最流行的授权框架，完美解决了第三方授权的问题。本文将从协议规范到代码实现，详细剖析OAuth2.0的工作原理。\n\n<!-- more -->\n\n## OAuth2.0协议规定\n\nOAuth2.0是一个关于授权的开放标准，允许用户授权第三方应用访问其在服务提供商上存储的特定资源，而无需将用户名和密码提供给第三方应用。\n\n### 核心角色\n\nOAuth2.0定义了四个核心角色：\n\n- **Resource Owner（资源所有者）**：通常是用户，拥有受保护资源的实体\n- **Client（客户端）**：需要访问用户资源的第三方应用\n- **Resource Server（资源服务器）**：存储受保护资源的服务器\n- **Authorization Server（授权服务器）**：验证用户身份并颁发访问令牌的服务器\n\n### 授权模式\n\nOAuth2.0定义了四种授权模式（Grant Type）：\n\n#### 授权码模式（Authorization Code）\n\n最完整、最安全的授权模式，适用于有后端的Web应用：\n\n```text\n     +----------+\n     | Resource |\n     |   Owner  |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier      +---------------+\n     |         -+----(A)-- & Redirection URI ---->|               |\n     |  User-   |                                 | Authorization |\n     |  Agent  -+----(B)-- User authenticates --->|     Server    |\n     |          |                                 |               |\n     |         -+----(C)-- Authorization Code ---<|               |\n     +-|----|---+                                 +---------------+\n       |    |                                         ^      v\n      (A)  (C)                                        |      |\n       |    |                                         |      |\n       ^    v                                         |      |\n     +---------+                                      |      |\n     |         |>---(D)-- Authorization Code ---------'      |\n     |  Client |          & Redirection URI                  |\n     |         |                                             |\n     |         |<---(E)----- Access Token -------------------'\n     +---------+       (w/ Optional Refresh Token)\n```\n\n#### 隐式模式（Implicit）\n\n简化模式，适用于纯前端应用，但安全性较低（已不推荐使用）：\n\n```text\n     +----------+\n     | Resource |\n     |  Owner   |\n     +----------+\n          ^\n          |\n         (B)\n     +----|-----+          Client Identifier     +---------------+\n     |         -+----(A)-- & Redirection URI --->|               |\n     |  User-   |                                | Authorization |\n     |  Agent  -|----(B)-- User authenticates -->|     Server    |\n     |          |                                |               |\n     |          |<---(C)--- Redirection URI ----<|               |\n     |          |          with Access Token     +---------------+\n     |          |            in Fragment\n     |          |                                +---------------+\n     |          |----(D)--- Redirection URI ---->|   Web-Hosted  |\n     |          |          without Fragment      |     Client    |\n     |          |                                |    Resource   |\n     |     (F)  |<---(E)------- Script ---------<|               |\n     |          |                                +---------------+\n     +-|--------+\n       |    |\n      (A)  (G) Access Token\n       |    |\n       ^    v\n     +---------+\n     |         |\n     |  Client |\n     |         |\n     +---------+\n```\n\n#### 密码模式（Resource Owner Password Credentials）\n\n用户直接把用户名密码给客户端，适用于高度信任的应用：\n\n```text\n     +----------+\n     | Resource |\n     |  Owner   |\n     +----------+\n          v\n          |    Resource Owner\n         (A) Password Credentials\n          |\n          v\n     +---------+                                  +---------------+\n     |         |>--(B)---- Resource Owner ------->|               |\n     |         |         Password Credentials     | Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(C)---- Access Token ---------<|               |\n     |         |    (w/ Optional Refresh Token)   |               |\n     +---------+                                  +---------------+\n```\n\n#### 客户端模式（Client Credentials）\n\n客户端以自己的名义请求访问令牌，适用于没有用户参与的场景：\n\n```text\n     +---------+                                  +---------------+\n     |         |                                  |               |\n     |         |>--(A)- Client Authentication --->| Authorization |\n     | Client  |                                  |     Server    |\n     |         |<--(B)---- Access Token ---------<|               |\n     |         |                                  |               |\n     +---------+                                  +---------------+\n```\n\n### Token类型\n\nOAuth2.0定义了两种Token：\n\n- **Access Token（访问令牌）**：用于访问受保护资源的凭证，有效期较短\n- **Refresh Token（刷新令牌）**：用于获取新的Access Token，有效期较长\n\n## Spring Security OAuth2.0服务端实现\n\n### 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.security</groupId>\n    <artifactId>spring-security-oauth2-authorization-server</artifactId>\n    <version>1.1.1</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>\n</dependency>\n```\n\n### 授权服务器配置\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class AuthorizationServerConfig {\n\n    @Bean\n    @Order(1)\n    public SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n        OAuth2AuthorizationServerConfiguration.applyDefaultSecurity(http);\n\n        http.getConfigurer(OAuth2AuthorizationServerConfigurer.class)\n            .oidc(Customizer.withDefaults()); // 启用OpenID Connect 1.0\n\n        http\n            .exceptionHandling((exceptions) -> exceptions\n                .defaultAuthenticationEntryPointFor(\n                    new LoginUrlAuthenticationEntryPoint(\"/login\"),\n                    new MediaTypeRequestMatcher(MediaType.TEXT_HTML)\n                )\n            )\n            .oauth2ResourceServer((resourceServer) -> resourceServer\n                .jwt(Customizer.withDefaults()));\n\n        return http.build();\n    }\n\n    @Bean\n    @Order(2)\n    public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests((authorize) -> authorize\n                .requestMatchers(\"/assets/**\", \"/webjars/**\", \"/login\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .formLogin(formLogin -> formLogin\n                .loginPage(\"/login\")\n            );\n\n        return http.build();\n    }\n\n    @Bean\n    public RegisteredClientRepository registeredClientRepository() {\n        RegisteredClient webClient = RegisteredClient.withId(UUID.randomUUID().toString())\n            .clientId(\"web-client\")\n            .clientSecret(\"{noop}secret\")\n            .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n            .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)\n            .authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)\n            .redirectUri(\"http://127.0.0.1:8080/login/oauth2/code/web-client\")\n            .redirectUri(\"http://127.0.0.1:8080/authorized\")\n            .postLogoutRedirectUri(\"http://127.0.0.1:8080/logged-out\")\n            .scope(OidcScopes.OPENID)\n            .scope(OidcScopes.PROFILE)\n            .scope(\"message.read\")\n            .scope(\"message.write\")\n            .clientSettings(ClientSettings.builder()\n                .requireAuthorizationConsent(true)\n                .requireProofKey(false)\n                .build())\n            .tokenSettings(TokenSettings.builder()\n                .accessTokenTimeToLive(Duration.ofMinutes(5))\n                .refreshTokenTimeToLive(Duration.ofMinutes(60))\n                .reuseRefreshTokens(false)\n                .build())\n            .build();\n\n        RegisteredClient mobileClient = RegisteredClient.withId(UUID.randomUUID().toString())\n            .clientId(\"mobile-client\")\n            .clientAuthenticationMethod(ClientAuthenticationMethod.NONE)\n            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n            .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)\n            .redirectUri(\"com.example.app://authorized\")\n            .scope(\"message.read\")\n            .clientSettings(ClientSettings.builder()\n                .requireAuthorizationConsent(false)\n                .requireProofKey(true) // 移动端使用PKCE\n                .build())\n            .build();\n\n        return new InMemoryRegisteredClientRepository(webClient, mobileClient);\n    }\n\n    @Bean\n    public JWKSource<SecurityContext> jwkSource() {\n        KeyPair keyPair = generateRsaKey();\n        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();\n        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();\n\n        RSAKey rsaKey = new RSAKey.Builder(publicKey)\n            .privateKey(privateKey)\n            .keyID(UUID.randomUUID().toString())\n            .build();\n\n        JWKSet jwkSet = new JWKSet(rsaKey);\n        return new ImmutableJWKSet<>(jwkSet);\n    }\n\n    private static KeyPair generateRsaKey() {\n        try {\n            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n            keyPairGenerator.initialize(2048);\n            return keyPairGenerator.generateKeyPair();\n        } catch (Exception ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    @Bean\n    public JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {\n        return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);\n    }\n\n    @Bean\n    public AuthorizationServerSettings authorizationServerSettings() {\n        return AuthorizationServerSettings.builder()\n            .issuer(\"http://localhost:9000\")\n            .build();\n    }\n}\n```\n\n### 自定义用户认证\n\n```java\n@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        User user = userRepository.findByUsername(username)\n            .orElseThrow(() -> new UsernameNotFoundException(\"用户不存在: \" + username));\n\n        return org.springframework.security.core.userdetails.User.builder()\n            .username(user.getUsername())\n            .password(user.getPassword())\n            .authorities(user.getRoles().stream()\n                .map(role -> new SimpleGrantedAuthority(\"ROLE_\" + role.getName()))\n                .collect(Collectors.toList()))\n            .build();\n    }\n}\n\n@Component\npublic class CustomOAuth2TokenCustomizer implements OAuth2TokenCustomizer<JwtEncodingContext> {\n\n    @Override\n    public void customize(JwtEncodingContext context) {\n        if (context.getTokenType().getValue().equals(OidcParameterNames.ID_TOKEN)) {\n            // 自定义ID Token\n            Authentication principal = context.getPrincipal();\n            Set<String> authorities = principal.getAuthorities().stream()\n                .map(GrantedAuthority::getAuthority)\n                .collect(Collectors.toSet());\n\n            context.getClaims().claim(\"authorities\", authorities);\n            context.getClaims().claim(\"user_id\", getUserId(principal));\n        }\n\n        if (context.getTokenType().equals(OAuth2TokenType.ACCESS_TOKEN)) {\n            // 自定义Access Token\n            Authentication principal = context.getPrincipal();\n            Set<String> scopes = context.getRegisteredClient().getScopes();\n\n            Set<String> authorizedScopes = principal.getAuthorities().stream()\n                .map(GrantedAuthority::getAuthority)\n                .filter(authority -> authority.startsWith(\"SCOPE_\"))\n                .map(authority -> authority.substring(6))\n                .filter(scopes::contains)\n                .collect(Collectors.toSet());\n\n            context.getClaims().claim(\"scopes\", authorizedScopes);\n        }\n    }\n\n    private Long getUserId(Authentication authentication) {\n        // 从认证信息中提取用户ID\n        if (authentication.getPrincipal() instanceof CustomUserDetails) {\n            return ((CustomUserDetails) authentication.getPrincipal()).getUserId();\n        }\n        return null;\n    }\n}\n```\n\n### 资源服务器配置\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class ResourceServerConfig {\n\n    @Bean\n    public SecurityFilterChain resourceServerSecurityFilterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests((authorize) -> authorize\n                .requestMatchers(\"/api/public/**\").permitAll()\n                .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN\")\n                .requestMatchers(\"/api/**\").authenticated()\n            )\n            .oauth2ResourceServer((oauth2) -> oauth2\n                .jwt((jwt) -> jwt\n                    .jwtAuthenticationConverter(jwtAuthenticationConverter())\n                )\n            );\n\n        return http.build();\n    }\n\n    @Bean\n    public JwtAuthenticationConverter jwtAuthenticationConverter() {\n        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();\n        grantedAuthoritiesConverter.setAuthorityPrefix(\"SCOPE_\");\n        grantedAuthoritiesConverter.setAuthoritiesClaimName(\"scopes\");\n\n        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();\n        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);\n        return jwtAuthenticationConverter;\n    }\n\n    @Bean\n    public JwtDecoder jwtDecoder() {\n        return NimbusJwtDecoder.withJwkSetUri(\"http://localhost:9000/oauth2/jwks\").build();\n    }\n}\n```\n\n### 自定义授权端点\n\n```java\n@Controller\npublic class AuthorizationConsentController {\n\n    @Autowired\n    private RegisteredClientRepository registeredClientRepository;\n\n    @GetMapping(\"/oauth2/consent\")\n    public String consent(Principal principal, Model model,\n                         @RequestParam(OAuth2ParameterNames.CLIENT_ID) String clientId,\n                         @RequestParam(OAuth2ParameterNames.SCOPE) String scope,\n                         @RequestParam(OAuth2ParameterNames.STATE) String state) {\n\n        RegisteredClient registeredClient = registeredClientRepository.findByClientId(clientId);\n\n        Set<String> scopesToApprove = new HashSet<>();\n        Set<String> previouslyApprovedScopes = new HashSet<>();\n\n        Set<String> requestedScopes = new HashSet<>(Arrays.asList(scope.split(\" \")));\n        Set<String> authorizedScopes = getAuthorizedScopes(principal, registeredClient);\n\n        for (String requestedScope : requestedScopes) {\n            if (authorizedScopes.contains(requestedScope)) {\n                previouslyApprovedScopes.add(requestedScope);\n            } else {\n                scopesToApprove.add(requestedScope);\n            }\n        }\n\n        model.addAttribute(\"clientId\", clientId);\n        model.addAttribute(\"clientName\", registeredClient.getClientName());\n        model.addAttribute(\"state\", state);\n        model.addAttribute(\"scopes\", scopesToApprove);\n        model.addAttribute(\"previouslyApprovedScopes\", previouslyApprovedScopes);\n        model.addAttribute(\"principalName\", principal.getName());\n\n        return \"consent\";\n    }\n\n    private Set<String> getAuthorizedScopes(Principal principal, RegisteredClient registeredClient) {\n        // 查询用户已授权的范围\n        // 实际应该从数据库查询\n        return new HashSet<>();\n    }\n}\n```\n\n## OAuth2.0客户端实现\n\n### 客户端配置\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class OAuth2ClientConfig {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n            .authorizeHttpRequests(authorize -> authorize\n                .requestMatchers(\"/\", \"/error\", \"/webjars/**\").permitAll()\n                .anyRequest().authenticated()\n            )\n            .oauth2Login(oauth2Login -> oauth2Login\n                .loginPage(\"/oauth2/authorization/web-client\")\n                .successHandler(oAuth2AuthenticationSuccessHandler())\n                .failureHandler(oAuth2AuthenticationFailureHandler())\n            )\n            .oauth2Client(Customizer.withDefaults());\n\n        return http.build();\n    }\n\n    @Bean\n    public OAuth2AuthenticationSuccessHandler oAuth2AuthenticationSuccessHandler() {\n        return new OAuth2AuthenticationSuccessHandler();\n    }\n\n    @Bean\n    public OAuth2AuthenticationFailureHandler oAuth2AuthenticationFailureHandler() {\n        return new OAuth2AuthenticationFailureHandler();\n    }\n}\n\n// 自定义成功处理器\npublic class OAuth2AuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request,\n                                      HttpServletResponse response,\n                                      Authentication authentication) throws IOException, ServletException {\n\n        OAuth2AuthenticationToken oAuth2Token = (OAuth2AuthenticationToken) authentication;\n        OAuth2User oAuth2User = oAuth2Token.getPrincipal();\n\n        // 获取用户信息\n        String email = oAuth2User.getAttribute(\"email\");\n        String name = oAuth2User.getAttribute(\"name\");\n        String picture = oAuth2User.getAttribute(\"picture\");\n\n        // 创建或更新本地用户\n        User localUser = userService.findOrCreateUser(email, name, picture);\n\n        // 更新认证信息\n        CustomOAuth2User customOAuth2User = new CustomOAuth2User(\n            oAuth2User.getAuthorities(),\n            oAuth2User.getAttributes(),\n            \"name\",\n            localUser.getId()\n        );\n\n        OAuth2AuthenticationToken newAuth = new OAuth2AuthenticationToken(\n            customOAuth2User,\n            customOAuth2User.getAuthorities(),\n            oAuth2Token.getAuthorizedClientRegistrationId()\n        );\n\n        SecurityContextHolder.getContext().setAuthentication(newAuth);\n\n        super.onAuthenticationSuccess(request, response, authentication);\n    }\n}\n```\n\n### 客户端配置文件\n\n```yaml\nspring:\n  security:\n    oauth2:\n      client:\n        registration:\n          web-client:\n            client-id: web-client\n            client-secret: secret\n            scope: openid, profile, message.read, message.write\n            authorization-grant-type: authorization_code\n            redirect-uri: \"{baseUrl}/login/oauth2/code/{registrationId}\"\n            client-name: Web Client\n\n          github:\n            client-id: ${GITHUB_CLIENT_ID}\n            client-secret: ${GITHUB_CLIENT_SECRET}\n            scope: read:user, user:email\n\n          google:\n            client-id: ${GOOGLE_CLIENT_ID}\n            client-secret: ${GOOGLE_CLIENT_SECRET}\n            scope: openid, profile, email\n\n        provider:\n          web-client:\n            authorization-uri: http://localhost:9000/oauth2/authorize\n            token-uri: http://localhost:9000/oauth2/token\n            jwk-set-uri: http://localhost:9000/oauth2/jwks\n            user-info-uri: http://localhost:9000/userinfo\n            user-name-attribute: sub\n```\n\n### 使用RestTemplate访问受保护资源\n\n```java\n@Service\npublic class OAuth2ResourceService {\n\n    @Autowired\n    private OAuth2AuthorizedClientService authorizedClientService;\n\n    @Autowired\n    private RestTemplateBuilder restTemplateBuilder;\n\n    public String getProtectedResource(OAuth2AuthenticationToken authentication) {\n        // 获取访问令牌\n        OAuth2AuthorizedClient authorizedClient = authorizedClientService.loadAuthorizedClient(\n            authentication.getAuthorizedClientRegistrationId(),\n            authentication.getName()\n        );\n\n        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();\n\n        // 使用访问令牌调用API\n        RestTemplate restTemplate = restTemplateBuilder.build();\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setBearerAuth(accessToken.getTokenValue());\n\n        HttpEntity<String> entity = new HttpEntity<>(headers);\n\n        ResponseEntity<String> response = restTemplate.exchange(\n            \"http://localhost:8080/api/messages\",\n            HttpMethod.GET,\n            entity,\n            String.class\n        );\n\n        return response.getBody();\n    }\n\n    // 自动刷新令牌\n    public OAuth2AccessToken refreshTokenIfExpired(OAuth2AuthorizedClient authorizedClient) {\n        if (isTokenExpired(authorizedClient.getAccessToken())) {\n            OAuth2RefreshToken refreshToken = authorizedClient.getRefreshToken();\n            if (refreshToken != null) {\n                return refreshAccessToken(authorizedClient, refreshToken);\n            }\n        }\n        return authorizedClient.getAccessToken();\n    }\n\n    private boolean isTokenExpired(OAuth2AccessToken accessToken) {\n        return accessToken.getExpiresAt() != null &&\n               Instant.now().isAfter(accessToken.getExpiresAt());\n    }\n\n    private OAuth2AccessToken refreshAccessToken(OAuth2AuthorizedClient authorizedClient,\n                                                OAuth2RefreshToken refreshToken) {\n        ClientRegistration clientRegistration = authorizedClient.getClientRegistration();\n\n        OAuth2RefreshTokenGrantRequest refreshTokenGrantRequest =\n            new OAuth2RefreshTokenGrantRequest(\n                clientRegistration,\n                authorizedClient.getAccessToken(),\n                refreshToken\n            );\n\n        DefaultRefreshTokenTokenResponseClient tokenResponseClient =\n            new DefaultRefreshTokenTokenResponseClient();\n\n        OAuth2AccessTokenResponse tokenResponse =\n            tokenResponseClient.getTokenResponse(refreshTokenGrantRequest);\n\n        return tokenResponse.getAccessToken();\n    }\n}\n```\n\n### WebClient集成OAuth2\n\n```java\n@Configuration\npublic class WebClientConfig {\n\n    @Bean\n    public WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {\n        ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =\n            new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);\n\n        oauth2Client.setDefaultClientRegistrationId(\"web-client\");\n\n        return WebClient.builder()\n            .baseUrl(\"http://localhost:8080\")\n            .filter(oauth2Client)\n            .build();\n    }\n\n    @Bean\n    public OAuth2AuthorizedClientManager authorizedClientManager(\n            ClientRegistrationRepository clientRegistrationRepository,\n            OAuth2AuthorizedClientRepository authorizedClientRepository) {\n\n        OAuth2AuthorizedClientProvider authorizedClientProvider =\n            OAuth2AuthorizedClientProviderBuilder.builder()\n                .authorizationCode()\n                .refreshToken()\n                .clientCredentials()\n                .password()\n                .build();\n\n        DefaultOAuth2AuthorizedClientManager authorizedClientManager =\n            new DefaultOAuth2AuthorizedClientManager(\n                clientRegistrationRepository,\n                authorizedClientRepository\n            );\n\n        authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);\n\n        return authorizedClientManager;\n    }\n}\n\n@Service\npublic class WebClientService {\n\n    @Autowired\n    private WebClient webClient;\n\n    public Mono<String> getResource() {\n        return webClient\n            .get()\n            .uri(\"/api/messages\")\n            .attributes(ServerOAuth2AuthorizedClientExchangeFilterFunction\n                .clientRegistrationId(\"web-client\"))\n            .retrieve()\n            .bodyToMono(String.class);\n    }\n\n    // 使用不同的客户端\n    public Mono<String> getResourceWithDifferentClient(String clientRegistrationId) {\n        return webClient\n            .get()\n            .uri(\"/api/data\")\n            .attributes(ServerOAuth2AuthorizedClientExchangeFilterFunction\n                .clientRegistrationId(clientRegistrationId))\n            .retrieve()\n            .bodyToMono(String.class);\n    }\n}\n```\n\n## 安全性考虑\n\n### PKCE（Proof Key for Code Exchange）\n\nPKCE用于增强公共客户端（如移动应用、SPA）的安全性：\n\n```java\n@Component\npublic class PKCEValidator {\n\n    public String generateCodeVerifier() {\n        SecureRandom secureRandom = new SecureRandom();\n        byte[] codeVerifier = new byte[32];\n        secureRandom.nextBytes(codeVerifier);\n        return Base64.getUrlEncoder().withoutPadding().encodeToString(codeVerifier);\n    }\n\n    public String generateCodeChallenge(String codeVerifier) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = digest.digest(codeVerifier.getBytes(StandardCharsets.US_ASCII));\n            return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public boolean verifyCodeChallenge(String codeVerifier, String codeChallenge,\n                                      String codeChallengeMethod) {\n        if (\"S256\".equals(codeChallengeMethod)) {\n            String computedChallenge = generateCodeChallenge(codeVerifier);\n            return computedChallenge.equals(codeChallenge);\n        } else if (\"plain\".equals(codeChallengeMethod)) {\n            return codeVerifier.equals(codeChallenge);\n        }\n        return false;\n    }\n}\n\n// 在授权服务器中验证PKCE\n@Component\npublic class PKCEAuthorizationCodeTokenGranter {\n\n    @Autowired\n    private PKCEValidator pkceValidator;\n\n    public OAuth2AccessToken grant(String authorizationCode, String codeVerifier) {\n        // 从存储中获取之前保存的code_challenge\n        AuthorizationCodeDetails codeDetails = getAuthorizationCodeDetails(authorizationCode);\n\n        if (codeDetails.getCodeChallenge() != null) {\n            // 验证PKCE\n            if (!pkceValidator.verifyCodeChallenge(codeVerifier,\n                                                   codeDetails.getCodeChallenge(),\n                                                   codeDetails.getCodeChallengeMethod())) {\n                throw new OAuth2AuthenticationException(\"Invalid code_verifier\");\n            }\n        }\n\n        // 继续正常的令牌颁发流程\n        return issueAccessToken(codeDetails);\n    }\n}\n```\n\n### 防止授权码拦截攻击\n\n```java\n@Component\npublic class AuthorizationCodeSecurityEnhancer {\n\n    private final Map<String, AuthorizationCodeMetadata> codeMetadataStore = new ConcurrentHashMap<>();\n\n    public String generateSecureAuthorizationCode(String clientId, String redirectUri) {\n        String code = generateRandomCode();\n\n        AuthorizationCodeMetadata metadata = new AuthorizationCodeMetadata();\n        metadata.setClientId(clientId);\n        metadata.setRedirectUri(redirectUri);\n        metadata.setIssuedAt(Instant.now());\n        metadata.setExpiresAt(Instant.now().plusSeconds(60)); // 1分钟有效期\n        metadata.setUsed(false);\n\n        codeMetadataStore.put(code, metadata);\n\n        // 定时清理过期的授权码\n        scheduleCodeCleanup(code, 60);\n\n        return code;\n    }\n\n    public void validateAuthorizationCode(String code, String clientId, String redirectUri) {\n        AuthorizationCodeMetadata metadata = codeMetadataStore.get(code);\n\n        if (metadata == null) {\n            throw new InvalidAuthorizationCodeException(\"授权码不存在\");\n        }\n\n        if (metadata.isUsed()) {\n            // 授权码已被使用，可能存在攻击，撤销所有相关令牌\n            revokeAllTokensForAuthorizationCode(code);\n            throw new InvalidAuthorizationCodeException(\"授权码已被使用\");\n        }\n\n        if (Instant.now().isAfter(metadata.getExpiresAt())) {\n            throw new InvalidAuthorizationCodeException(\"授权码已过期\");\n        }\n\n        if (!metadata.getClientId().equals(clientId)) {\n            throw new InvalidAuthorizationCodeException(\"客户端ID不匹配\");\n        }\n\n        if (!metadata.getRedirectUri().equals(redirectUri)) {\n            throw new InvalidAuthorizationCodeException(\"重定向URI不匹配\");\n        }\n\n        // 标记为已使用\n        metadata.setUsed(true);\n    }\n\n    private String generateRandomCode() {\n        return UUID.randomUUID().toString();\n    }\n\n    private void scheduleCodeCleanup(String code, long delaySeconds) {\n        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n        executor.schedule(() -> codeMetadataStore.remove(code), delaySeconds, TimeUnit.SECONDS);\n    }\n\n    @Data\n    private static class AuthorizationCodeMetadata {\n        private String clientId;\n        private String redirectUri;\n        private Instant issuedAt;\n        private Instant expiresAt;\n        private boolean used;\n    }\n}\n```\n\n### Token安全存储\n\n```java\n@Service\npublic class SecureTokenStore {\n\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n\n    private static final String ACCESS_TOKEN_PREFIX = \"access_token:\";\n    private static final String REFRESH_TOKEN_PREFIX = \"refresh_token:\";\n\n    // 使用加密存储敏感令牌\n    public void storeAccessToken(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n        String tokenKey = extractTokenKey(accessToken.getValue());\n        String encryptedToken = encrypt(accessToken.getValue());\n\n        OAuth2AccessTokenEntity entity = new OAuth2AccessTokenEntity();\n        entity.setTokenValue(encryptedToken);\n        entity.setTokenType(accessToken.getTokenType());\n        entity.setScopes(accessToken.getScopes());\n        entity.setExpiresAt(accessToken.getExpiresAt());\n        entity.setAuthentication(serializeAuthentication(authentication));\n\n        redisTemplate.opsForValue().set(\n            ACCESS_TOKEN_PREFIX + tokenKey,\n            JsonUtils.toJson(entity),\n            accessToken.getExpiresAt().toEpochMilli() - System.currentTimeMillis(),\n            TimeUnit.MILLISECONDS\n        );\n    }\n\n    public OAuth2AccessToken readAccessToken(String tokenValue) {\n        String tokenKey = extractTokenKey(tokenValue);\n        String json = redisTemplate.opsForValue().get(ACCESS_TOKEN_PREFIX + tokenKey);\n\n        if (json == null) {\n            return null;\n        }\n\n        OAuth2AccessTokenEntity entity = JsonUtils.fromJson(json, OAuth2AccessTokenEntity.class);\n\n        // 验证令牌\n        String decryptedToken = decrypt(entity.getTokenValue());\n        if (!decryptedToken.equals(tokenValue)) {\n            throw new InvalidTokenException(\"令牌验证失败\");\n        }\n\n        return new OAuth2AccessToken(\n            entity.getTokenType(),\n            tokenValue,\n            entity.getIssuedAt(),\n            entity.getExpiresAt(),\n            entity.getScopes()\n        );\n    }\n\n    // Token撤销\n    public void revokeToken(String tokenValue) {\n        String tokenKey = extractTokenKey(tokenValue);\n        redisTemplate.delete(ACCESS_TOKEN_PREFIX + tokenKey);\n\n        // 记录撤销的令牌，防止重放攻击\n        recordRevokedToken(tokenValue);\n    }\n\n    private void recordRevokedToken(String tokenValue) {\n        String tokenKey = extractTokenKey(tokenValue);\n        redisTemplate.opsForSet().add(\"revoked_tokens\", tokenKey);\n        // 设置过期时间为令牌的原始过期时间\n        redisTemplate.expire(\"revoked_tokens\", 24, TimeUnit.HOURS);\n    }\n\n    public boolean isTokenRevoked(String tokenValue) {\n        String tokenKey = extractTokenKey(tokenValue);\n        return redisTemplate.opsForSet().isMember(\"revoked_tokens\", tokenKey);\n    }\n\n    private String extractTokenKey(String value) {\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"MD5算法不可用\");\n        }\n\n        byte[] bytes = digest.digest(value.getBytes(StandardCharsets.UTF_8));\n        return String.format(\"%032x\", new BigInteger(1, bytes));\n    }\n\n    private String encrypt(String value) {\n        // 实现加密逻辑\n        // 这里应该使用AES等对称加密算法\n        return Base64.getEncoder().encodeToString(value.getBytes());\n    }\n\n    private String decrypt(String encryptedValue) {\n        // 实现解密逻辑\n        return new String(Base64.getDecoder().decode(encryptedValue));\n    }\n}\n```\n\n### 防止重放攻击\n\n```java\n@Component\npublic class NonceValidator {\n\n    private final Cache<String, Boolean> nonceCache = CacheBuilder.newBuilder()\n        .maximumSize(10000)\n        .expireAfterWrite(5, TimeUnit.MINUTES)\n        .build();\n\n    public String generateNonce() {\n        return UUID.randomUUID().toString();\n    }\n\n    public void validateNonce(String nonce) {\n        if (StringUtils.isEmpty(nonce)) {\n            throw new InvalidNonceException(\"Nonce不能为空\");\n        }\n\n        Boolean exists = nonceCache.getIfPresent(nonce);\n        if (exists != null) {\n            throw new InvalidNonceException(\"Nonce已被使用\");\n        }\n\n        nonceCache.put(nonce, true);\n    }\n}\n\n@RestController\n@RequestMapping(\"/oauth2\")\npublic class OAuth2EndpointController {\n\n    @Autowired\n    private NonceValidator nonceValidator;\n\n    @PostMapping(\"/token\")\n    public OAuth2AccessToken issueToken(@RequestParam Map<String, String> parameters) {\n        // 验证nonce防止重放攻击\n        String nonce = parameters.get(\"nonce\");\n        nonceValidator.validateNonce(nonce);\n\n        // 验证时间戳\n        String timestamp = parameters.get(\"timestamp\");\n        validateTimestamp(timestamp);\n\n        // 继续正常的令牌颁发流程\n        return processTokenRequest(parameters);\n    }\n\n    private void validateTimestamp(String timestamp) {\n        if (timestamp == null) {\n            throw new InvalidRequestException(\"缺少时间戳\");\n        }\n\n        long requestTime = Long.parseLong(timestamp);\n        long currentTime = System.currentTimeMillis();\n\n        // 允许5分钟的时间差\n        if (Math.abs(currentTime - requestTime) > 5 * 60 * 1000) {\n            throw new InvalidRequestException(\"请求已过期\");\n        }\n    }\n}\n```\n\n### 审计日志\n\n```java\n@Component\n@Slf4j\npublic class OAuth2AuditLogger {\n\n    @Autowired\n    private AuditLogRepository auditLogRepository;\n\n    @EventListener\n    public void handleAuthorizationSuccess(AuthorizationSuccessEvent event) {\n        AuditLog auditLog = new AuditLog();\n        auditLog.setEventType(\"AUTHORIZATION_SUCCESS\");\n        auditLog.setClientId(event.getClientId());\n        auditLog.setUsername(event.getUsername());\n        auditLog.setScopes(String.join(\",\", event.getScopes()));\n        auditLog.setIpAddress(event.getIpAddress());\n        auditLog.setTimestamp(Instant.now());\n\n        auditLogRepository.save(auditLog);\n        log.info(\"授权成功: clientId={}, username={}, scopes={}\",\n                event.getClientId(), event.getUsername(), event.getScopes());\n    }\n\n    @EventListener\n    public void handleAuthorizationFailure(AuthorizationFailureEvent event) {\n        AuditLog auditLog = new AuditLog();\n        auditLog.setEventType(\"AUTHORIZATION_FAILURE\");\n        auditLog.setClientId(event.getClientId());\n        auditLog.setUsername(event.getUsername());\n        auditLog.setErrorCode(event.getErrorCode());\n        auditLog.setErrorDescription(event.getErrorDescription());\n        auditLog.setIpAddress(event.getIpAddress());\n        auditLog.setTimestamp(Instant.now());\n\n        auditLogRepository.save(auditLog);\n        log.warn(\"授权失败: clientId={}, username={}, error={}\",\n                event.getClientId(), event.getUsername(), event.getErrorCode());\n\n        // 检测异常行为\n        detectAnomalies(event);\n    }\n\n    private void detectAnomalies(AuthorizationFailureEvent event) {\n        // 检查短时间内的失败次数\n        long recentFailures = auditLogRepository.countRecentFailures(\n            event.getClientId(),\n            event.getIpAddress(),\n            Instant.now().minusSeconds(300) // 5分钟内\n        );\n\n        if (recentFailures > 5) {\n            // 触发安全警报\n            sendSecurityAlert(event);\n            // 可以考虑临时封禁IP或客户端\n            blockTemporarily(event.getIpAddress());\n        }\n    }\n\n    private void sendSecurityAlert(AuthorizationFailureEvent event) {\n        // 发送安全警报邮件或消息\n        log.error(\"安全警报: 检测到异常授权尝试 - IP: {}, ClientId: {}\",\n                 event.getIpAddress(), event.getClientId());\n    }\n\n    private void blockTemporarily(String ipAddress) {\n        // 实现IP临时封禁逻辑\n        redisTemplate.opsForValue().set(\n            \"blocked_ip:\" + ipAddress,\n            \"true\",\n            15,\n            TimeUnit.MINUTES\n        );\n    }\n}\n```\n"},{"title":"算能边缘计算设备开发环境的搭建指北","tags":["模型部署","嵌入式","深度学习"],"categories":["嵌入式"],"author":"Katyusha0x26d","excerpt":"\n[算能（Sophgo）](https://www.sophgo.com/about-us/index.html)是国内开发边缘计算处理器比较著名的公司\n\n参加的一次竞赛，在使用其`cv181x`处理器部署深度学习模型时，因为开发环境[`cviruntime`](https://github.com/sophgo/cviruntime)的官方文档不是很完整，所以在开发环境的搭建上折腾了一小段时间，随后便写下此文记录我个人的解决方案，以供新手查阅\n\n","link":"/posts/sophgo-runtime-setup","content":"\n[算能（Sophgo）](https://www.sophgo.com/about-us/index.html)是国内开发边缘计算处理器比较著名的公司\n\n参加的一次竞赛，在使用其`cv181x`处理器部署深度学习模型时，因为开发环境[`cviruntime`](https://github.com/sophgo/cviruntime)的官方文档不是很完整，所以在开发环境的搭建上折腾了一小段时间，随后便写下此文记录我个人的解决方案，以供新手查阅\n\n<!-- more -->\n\n## 安装WSL2\n\n:::tip\n\n对于在Windows 11上已经安装了VMware Workstation Pro虚拟机以及搭建好了Linux开发环境的读者，可以跳过该章节\n\n:::\n\n应用开发使用C++和`cviruntime`、`OpenCV`进行**交叉编译**，因此需要配置一个适合用于交叉编译的环境，我推荐习惯Windows的读者使用[`Windows Subsystem for Linux`](https://learn.microsoft.com/zh-cn/windows/wsl/)\n\n### 先决条件\n\n请在`控制面板->程序->启用或关闭Windows功能`里，启用`Hyper-V`、`Virtual Machine Platform`、`Windows虚拟机监控程序平台`、`适用于Linux的Windows子系统`，随后重启\n\n### 安装Ubuntu WSL2\n\n在Windows 11及更新的系统上，使用如下指令安装WSL2：\n\n```shell\nwsl --install -d Ubuntu\n```\n\n安装完成后将会提示你创建用户以及输入用户登录密码\n\n::: tip\n\n如果提示你升级WSL内核，请前往[下载 Linux 内核更新包 - Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package)安装更新包并重新安装Ubuntu WSL\n\n:::\n\n### 可选-将WSL移动到其它驱动器\n\nWSL默认安装于C盘，如果你的C盘空间不够或者你有*极强的文件约束习惯*，可以使用以下操作将已安装的WSL移动到其它驱动器（请将我的目录地址以及用户名等修改为你的实际值）：\n\n备份原有的WSL操作系统：\n\n```shell\nwsl --export Ubuntu D:\\Archives\\ubuntu-wsl-initial.tar\n```\n\n卸载已安装的WSL：\n\n```shell\nwsl --unregister Ubuntu\n```\n\n将WSL安装到其它驱动器的新位置：\n\n```shell\nwsl --import Ubuntu D:\\VirtualMachines\\WSL\\Ubuntu D:\\Archives\\ubuntu-wsl-initial.tar\n```\n\n配置wsl默认用户：\n\n```shell\nwsl --manage Ubuntu --set-default-user maxwell\n```\n\n（可选）配置wsl命令默认指代的实例，如果你同时安装了Docker Desktop，或者其他的WSL实例，请执行以下操作：\n\n```shell\nwsl --set-default Ubuntu\n```\n\n## 安装Docker\n\nDocker基于Linux命名空间实现资源隔离，因此可以很方便地在一个操作系统内部署多个不同的应用环境而互相不受影响\n\n在Windows上安装Docker即在Windows上的Linux环境里安装Docker，读者可以选择在VMware Workstation Pro的Linux虚拟机里安装，也可以选择直接使用Docker Desktop\n\nDocker Desktop使用WSL2提供的Linux环境，因此若想使用Docker Desktop需要预先确保Hyper-V以及WSL2已经被正确安装\n\n随后转到[Docker Desktop的官方网站](https://www.docker.com/products/docker-desktop/)下载并安装Docker Desktop\n\n![安装好的Docker Desktop](https://lc-gluttony.s3.amazonaws.com/6Beck3SuJkGW/cxbt0vPW8MDJFwnSBJhXaCU4T4yARs1t/Snipaste_2025-04-24_19-10-58.png \"安装好的Docker Desktop\")\n\n## 配置vscode\n\n建议使用Microsoft VS Code作为你的编辑器，如果没有，请前往[官网](https://code.visualstudio.com/)下载并安装\n\n### 安装插件\n\n对于C++开发建议使用clangd提供自动补全以及错误检查，为此你需要安装clangd插件。连接远程Linux系统需要使用SSH，因此你需要安装Remote Development捆绑插件\n\n## 搭建基本Linux开发环境\n\n使用以下指令连接上安装好的Ubuntu WSL：\n\n```shell\nwsl -d Ubuntu --cd ~\n```\n\n![进入WSL示例](https://lc-gluttony.s3.amazonaws.com/6Beck3SuJkGW/WJrG6XETXaqmgkCbvi8MFVP01xArogaW/Snipaste_2025-04-24_13-08-04.png \"进入WSL示例\")\n\n### 更换软件源\n\n在Ubuntu上，更换APT软件源，如果你想使用[清华大学开源软件镜像站](https://mirrors.tuna.tsinghua.edu.cn/)，请转到[他们的帮助页面](https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/)查看如何更换软件源\n\n补一张换源后的`/etc/apt/sources.list.d/ubuntu.sources`\n\n![ubuntu.sources示例](https://lc-gluttony.s3.amazonaws.com/6Beck3SuJkGW/xDLAi18VEoHk8NaPGc2t6aHeHnWFQEyv/Snipaste_2025-04-24_13-10-12.png \"ubuntu.sources示例\")\n\n### 安装基本软件\n\n使用以下命令安装基本环境：\n\n```shell\nsudo apt install gcc g++ git cmake ninja-build python3 python3-pip clangd\n```\n\n### 创建工具链目录\n\n可以在用户主目录下创建一个`sophgo`目录用来存放`TPU SDK`、`opencv-mobile`以及`riscv host-tools`\n\n```shell\ncd ~\nmkdir sophgo\n```\n\n### 安装交叉编译工具链\n\n算能cv181x具有两个架构的处理器：ARM和Risc-V\n\n`git clone` 算能Risc-V工具链的编译后二进制仓库：\n\n```shell\ngit clone https://github.com/sophgo/host-tools.git\n```\n\n::: warning\n\n对于Risc-V，**此处**我们要使用的是`musl libc`而不是`glibc`，有关二者区别，请参考：\n\n[1.glibc和musl libc的区别](https://www.cnblogs.com/youxin/p/17818574.html)\n\n[2.Functional differences from glibc](https://wiki.musl-libc.org/functional-differences-from-glibc.html)\n\n:::\n\n### 配置环境变量\n\n我推荐使用一些Linux发行版例如`openSUSE`的做法，对于用户安装的应用，可以将其可执行文件链接到`~/bin`目录下\n\n```shell\nmkdir ~/bin\nln -s ~/sophgo/host-tools/gcc/riscv64-linux-musl-x86_64/bin/riscv64-unknown-linux-musl-* ~/bin\n```\n\n通过以下命令可以检验软软链接是否被正确设置\n\n```shell\nls -l ~/bin/riscv64-unknown-linux-musl-*\n```\n\n如果正确地设置了软链接，那么会有下图所示的输出：\n\n![使用ls -l检查软链接](https://lc-gluttony.s3.amazonaws.com/6Beck3SuJkGW/JuMjd1XwcHbmOKa9xPUnM6NTfRnEMI31/Snipaste_2025-04-29_10-48-05.png \"使用ls -l检查软链接\")\n\n设置软链接后，执行任意`~/bin/`下的可执行文件就会实际上执行链接的目标文件\n\n随后将`~/bin`目录添加进`PATH`环境变量即可，编辑`~/.bashrc`文件，在结尾处添加：\n\n```shell\nexport PATH=~/bin/:$PATH\n```\n\n关闭终端并重新打开，此时已经应用了新的环境变量，不出意外，此时执行`riscv64-unknown-linux-musl-gcc -v`会有输出：\n\n![riscv64-unknown-linux-musl-gcc的执行输出](https://lc-gluttony.s3.amazonaws.com/6Beck3SuJkGW/SVb1WUJFrdGHmoednWvgQkjuBlfvarcm/Snipaste_2025-04-29_10-54-17.png \"riscv64-unknown-linux-musl-gcc的执行输出\")\n\n## 搭建cviruntime环境\n\n在算能设备上推理模型需要使用`cviruntime`调用其TPU，起初我使用Sophgo维护的`cviruntime`和`cvikernel`，结果因为该项目文档极少且**错误较多**屡次编译失败，最后找到了milkv-duo维护的`sg200x-tpu-sdk`，遂改为使用该SDK开发\n\n### 克隆TPU-SDK仓库\n\n切换到工具链目录`git clone` SDK仓库\n\n```shell\ngit clone https://github.com/milkv-duo/tpu-sdk-sg200x.git tpu-sdk\n```\n\n### 搭建模型开发环境\n\n安装PyTorch、Jetbrains PyCharm，此处略过\n\n### 搭建模型转换环境\n\n在Docker Desktop里拉取`sophgo/tpuc_dev:latest`镜像\n\n打开powershell使用下述命令启动容器：\n\n```shell\n docker run --name tpuc_dev -v /workspace -it sophgo/tpuc_dev:latest\n```\n\n::: warning\n\nmilkv-duo的文档启动时具有一个参数`--privileged`，因为处于特权模式下的容器root用户具有与宿主机root用户相同的权限，我建议去掉该参数以保证安全性，关于利用Docker特权模式进行容器逃逸，请见[记一次Docker下的Privileged特权模式容器逃逸](https://www.isisy.com/1510.html)\n\n:::\n\n对于已经启动的容器，可以登录上去：\n\n```shell\ndocker exec -it tpuc_dev /bin/bash\n```\n\n在工作目录`git clone` 转换工具仓库\n\n```shell\ngit clone https://github.com/milkv-duo/tpu-mlir.git\n```\n\n### 搭建opencv-mobile开发环境\n\nMilkv-duo为开发板适配了`opencv-mobile`，其与`opencv`相比更精简，且适配了一些外设，例如在使用`CAM-GC2083`时，如果使用`opencv-mobile`直接调用摄像头，那么此时就会更方便\n\n安装方法很简单，在工具链目录下载并解压缩最新的发行版即可：\n\n```shell\ncd sophgo\nwget https://github.com/nihui/opencv-mobile/releases/latest/download/opencv-mobile-4.11.0-milkv-duo.zip\nunzip opencv-mobile-4.11.0-milkv-duo.zip\nmv opencv-mobile-4.11.0-milkv-duo/ opencv-mobile\nrm opencv-mobile-4.11.0-milkv-duo.zip\n```\n\n::: tip\n\n如果提示找不到命令unzip，使用包管理器安装\n\n:::\n\n## 测试环境\n\n我们将在设备上部署[Facebook Research](https://ai.meta.com/research/)的[`DinoV2特征提取器`](https://arxiv.org/pdf/2304.07193)测试环境搭建是否正确\n\n### 获取onnx模型\n\n::: warning\n\n这篇博客的[之前某一个版本（2025.4.25 23:38，Commit:7f984a3）](https://github.com/Katyusha0x26d/blog/commit/7f984a3521e7b4759b62b87ef59bb485bc2c9ec2)里我直接使用`DinoV2`进行`ImageNet`预测，这实际上是不对的，因为`DinoV2`只是一个特征提取器，不是一个分类器，如果读者想要对图像进行分类，应该在`DinoV2`骨干网络后增加一个分类头，而不是直接使用骨干网络进行分类\n\n在读者目前看到的文章版本里，这个错误已经被修复\n\n:::\n\n通过torch加载位于TorchHub的预训练模型，查看模型的详细信息并导出为onnx格式\n\n```python\nimport torch\nimport torchinfo\n\ndinov2_vits14 = torch.hub.load('facebookresearch/dinov2', 'dinov2_vits14', pretrained=True)\ntorchinfo.summary(dinov2_vits14, (1, 3, 448, 448))\n```\n\n```output\n==========================================================================================\nLayer (type:depth-idx)                   Output Shape              Param #\n==========================================================================================\nDinoVisionTransformer                    [1, 384]                  526,848\n├─PatchEmbed: 1-1                        [1, 1024, 384]            226,176\n├─ModuleList: 1-2                        --                        21,302,784\n├─LayerNorm: 1-3                         [1, 1025, 384]            768\n├─Identity: 1-4                          [1, 384]                  --\n==========================================================================================\nTotal params: 22,056,576\nTrainable params: 22,056,576\nNon-trainable params: 0\nTotal mult-adds (Units.MEGABYTES): 252.90\n==========================================================================================\nInput size (MB): 2.41\nForward/backward pass size (MB): 497.51\nParams size (MB): 86.12\nEstimated Total Size (MB): 586.03\n==========================================================================================\n```\n\n::: danger\n\n如果仅仅将上述获得的模型导出为onnx格式，那么由于模型`forward`函数具有额外的除了张量以外的参数，会导致后续处理onnx模型时存在问题，因此我们需要对原有模型进行包装\n\n:::\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass WrappedModel(nn.Module):\n    def __init__(self, model):\n        super().__init__()\n        self.model = model\n\n    def forward(self, x):\n        return F.softmax(self.model(x), dim=1)\n\ntest_inputs = torch.randn(1, 3, 448, 448)\nmodel = WrappedModel(dinov2_vits14)\n\ntorch.onnx.export(model, test_inputs, dynamo=False, f='dinov2_vits14.onnx', external_data=False)\n```\n\n导出后onnx模型即为`dinov2_vits14.onnx`\n\n::: tip\n\n如果提示torch缺失依赖库`onnx`、`onnxruntime`，安装即可\n\n:::\n\n::: tip\n\n如果在安装onnx时，安装失败，出现子命令执行错误，以及cmake的运行错误提示，这可能是因为你的Python版本过高，onnx暂时没有为你的Python版本发布的二进制已编译的发行版，因此onnx在安装时会尝试从源码开始构建，那么此时如果你缺失了`ProtoBuf`等依赖库，就会编译错误\n\n最为简单的解决方案是将Python降级一个版本，例如在我写这篇文章时，是2025年四月，我的环境使用的是`Python 3.13.3`，而onnx最高只有`Python 3.12`的已编译的发行版，此时就出现了这个错误，将Python降级为3.12.10即可解决该错误\n\n:::\n\n::: tip\n\n如果你在安装onnx时，又出现了`文件名或扩展名太长`错误，这是因为Windows系统对于文件路径最长限制在260个字符，这可以在Windows 10/11上通过修改注册表键`HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\\LongPathsEnabled`，将键值设置为1解决，具体请参考[最大路径长度限制-Microsoft文档](https://learn.microsoft.com/zh-cn/windows/win32/fileio/maximum-file-path-limitation?tabs=registry)\n\n:::\n\n### 将onnx模型转换为cvimodel\n\n进入转换工具的Docker环境，设置环境变量\n\n```shell\nsource tpu-mlir/envsetup.sh\nmkdir dinov2 && cd dinov2\n```\n\n获取一部分图片用于生成校准数据，读者可以自行按照部署环境情况获取图片，也可以使用现有数据集，例如`ImageNet-1k`等\n\n将onnx模型上传到Docker容器\n\n```shell\ndocker cp dinov2_vits14.onnx tpuc_dev:/workspace/dinov2/dinov2_vits14.onnx\n```\n\n利用`model_transform.py`将模型转换为`mlir`格式\n\n```shell\nmodel_transform.py \\\n--model_name dinov2_vits14 \\\n--model_def dinov2_vits14.onnx \\\n--input_shapes [[1,3,448,448]] \\\n--pixel_format \"rgb\" \\\n--mean 123.675,116.28,103.53 \\\n--scale 0.0171,0.0175,0.0174 \\\n--mlir dinov2_vits14.mlir\n```\n\n使用`run_calibration.py`生成校准表\n\n```shell\nrun_calibration.py dinov2_vits14.mlir \\\n--dataset imagenet \\\n--input_num 100 \\\n-o dinov2_vits14_calib_table\n```\n\n将MLIR量化成INT8非对称cvimodel，并添加`--fuse_preprocess`选项将预处理阶段集成在模型内部：\n\n```shell\nmodel_deploy.py \\\n--mlir dinov2_vits14.mlir \\\n--asymmetric \\\n--calibration_table dinov2_vits14_calib_table \\\n--chip cv181x \\\n--fuse_preprocess \\\n--quantize INT8 \\\n--model dinov2_vits14.cvimodel\n```\n\n完成转换后，使用`model_tool`查看cvimodel信息\n\n```shell\nmodel_tool\n```\n\n### 编写cvimodel推理程序\n\n在之前安装的Ubuntu WSL上创建项目文件夹，配置clangd插件，配置项目\n\n```shell\nmkdir guidance && cd guidance\nmkdir build\nmkdir .vscode && touch .vscode/settings.json\ntouch CMakeLists.txt\ntouch main.cpp\ntouch .clangd\n```\n\n编辑vscode的工作区插件配置文件`.vscode/settings.json`：\n\n```json\n{\n    \"clangd.arguments\": [\n        \"--log=verbose\",\n        \"--background-index\",\n        \"--compile-commands-dir=build\",\n        \"-j=12\",\n        \"--clang-tidy\",\n        \"--all-scopes-completion\",\n        \"--header-insertion=never\",\n        \"--completion-style=detailed\",\n        \"--function-arg-placeholders\",\n        \"--pch-storage=memory\",\n        \"--fallback-style=LLVM\",\n        \"--suggest-missing-includes\",\n    ]\n}\n```\n\n编辑clangd配置文件`.clangd`以移除march和mcpu选项，防止因为clangd内置的引擎不支持这些选项造成错误误报\n\n```yaml\nCompileFlags:\n    Remove:\n        - \"-march=*\"\n        - \"-mcpu=*\"\n```\n\n编辑项目配置`CMakeLists.txt`\n\n```cmake\ncmake_minimum_required(VERSION 3.25)\n\nset(SOPHGO_TOOLCHAIN_PATH /home/maxwell/sophgo)\nset(TPU_SDK_PATH ${SOPHGO_TOOLCHAIN_PATH}/tpu-sdk)\nset(TOOLCHAIN riscv64-linux-musl-x86_64)\nset(CMAKE_TOOLCHAIN_FILE ${TPU_SDK_PATH}/cmake/toolchain-${TOOLCHAIN}.cmake)\n\nproject(guidance CXX)\n\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_C_STANDARD 11)\n\nset(HOST_TOOLS_PATH ${SOPHGO_TOOLCHAIN_PATH}/host-tools)\nset(CMAKE_SYSROOT ${HOST_TOOLS_PATH}/gcc/${TOOLCHAIN}/sysroot)\n\nset(OPENCV_MOBILE_PATH ${SOPHGO_TOOLCHAIN_PATH}/opencv-mobile)\nset(OpenCV_DIR ${OPENCV_MOBILE_PATH}/lib/cmake/opencv4)\nfind_package(OpenCV REQUIRED)\n\nset(FLATBUFFERS_PATH ${TPU_SDK_PATH}/flatbuffers)\nset(Flatbuffers_DIR ${FLATBUFFERS_PATH}/lib/cmake/flatbuffers)\nfind_package(Flatbuffers REQUIRED)\n\ninclude_directories(${TPU_SDK_PATH}/include)\n\nadd_executable(guidance\n    main.cpp\n)\n\nlink_libraries(${TPU_SDK_PATH}/lib)\nfile(GLOB CVI_LIBS ${TPU_SDK_PATH}/lib/libcvi*.so)\n\ntarget_link_libraries(guidance\n    ${OpenCV_LIBS}\n    ${CVI_LIBS}\n)\n```\n\n编辑C++程序`main.cpp`\n\n```c++\n#include <cviruntime.h>\n#include <opencv2/opencv.hpp>\n\nvoid usage(char *program_name) {\n    printf(\"Usage: %s <model> <image>\\n\", program_name);\n}\n\nint main(int argc, char **argv) {\n    if (argc < 3) {\n        usage(argv[0]);\n        return EXIT_FAILURE;\n    }\n    const char *model_path = argv[1];\n    const char *image_path = argv[2];\n    // load model\n    CVI_MODEL_HANDLE model = nullptr;\n    int rc = CVI_NN_RegisterModel(model_path, &model);\n    if (rc != CVI_RC_SUCCESS) {\n        printf(\"CVI_NN_RegisterModel failed, err %d\\n\", rc);\n        return EXIT_FAILURE;\n    }\n    CVI_TENSOR *input_tensors, *output_tensors;\n    int32_t input_num, output_num;\n    CVI_NN_GetInputOutputTensors(model, &input_tensors, &input_num, &output_tensors, &output_num);\n    CVI_TENSOR *input = CVI_NN_GetTensorByName(CVI_NN_DEFAULT_TENSOR, input_tensors, input_num);\n    CVI_TENSOR *output = CVI_NN_GetTensorByName(CVI_NN_DEFAULT_TENSOR, output_tensors, output_num);\n    float input_qscale = CVI_NN_TensorQuantScale(input);\n    printf(\"input qscale: %f\\n\", input_qscale);\n    CVI_SHAPE input_shape = CVI_NN_TensorShape(input);\n    int32_t input_height = input_shape.dim[2];\n    int32_t input_width = input_shape.dim[3];\n    // Load input image\n    cv::Mat bgr_image = cv::imread(image_path);\n    if (!bgr_image.data) {\n        printf(\"Could not open image\\n\");\n        return EXIT_FAILURE;\n    }\n    cv::Mat image;\n    cv::resize(bgr_image, image, cv::Size(input_width, input_height));\n    cv::cvtColor(image, image, cv::COLOR_BGR2RGB);\n    cv::Size size = cv::Size(input_width, input_height);\n    cv::Mat channels[3];\n    for (int i = 0; i < 3; i++) {\n        channels[i]  = cv::Mat(input_width, input_height, CV_8SC1);\n    }\n    cv::split(image, channels);\n    for (int i = 0; i < 3; i++) {\n        channels[i].convertTo(channels[i], CV_8SC1, input_qscale, 0);\n    }\n    // input image to model\n    int8_t *input_ptr = (int8_t *)CVI_NN_TensorPtr(input);\n    int channel_size = input_height * input_width;\n    for (int i = 0; i < 3; i++) {\n        memcpy(input_ptr + i * channel_size, channels[i].data, channel_size);\n    }\n    // run inference\n    CVI_NN_Forward(model, input_tensors, input_num, output_tensors, output_num);\n    printf(\"CVI_NN_Forward succeeded.\\n\");\n    // Output results\n    float *features = (float *)CVI_NN_TensorPtr(output);\n    int count = CVI_NN_TensorCount(output);\n    printf(\"----------------\\n\");\n    printf(\"Image feature: \");\n    for (int i = 0; i < count; i++) {\n        printf(\"%.3f \", features[i]);\n    }\n    printf(\"\\n\");\n    printf(\"----------------\\n\");\n    // cleanup\n    CVI_NN_CleanupModel(model);\n    printf(\"CVI_NN_CleanupModel succeeded\\n\");\n    return 0;\n}\n```\n\n随后执行cmake配置，可以使用vscode自动配置也可以进入build目录手动配置\n\n随后打开`main.cpp`可以看到clangd已经没有报错了，按住CTRL左键点击任何函数也能跳转到定义\n\n切换到`build`目录，执行`ninja`或者使用cmake插件自动编译也可以\n\n生成了`guidance`这个可执行文件，我们使用SCP将其以及cvimodel模型、测试图片传输到设备上\n\n```shell\nscp -O guidance imagenet/ILSVRC2012_val_00000178.JPEG dinov2_vits14.cvimodel root@192.168.42.1:/root\n```\n\n### cviruntime的测试结果\n\n使用SSH登录设备，给编译后的二进制文件授予可执行权限：\n\n```shell\nchmod +x guidance\n```\n\n执行程序获得结果，注意此处结果只是一个384长度的向量，因为我们使用的模型是一个特征提取器而不是分类器，对于常见的分类模型，分类器会将特征提取器的输出经过一个全连接层，随后经过 $softmax$ 后才会得到`num_classes` 个类的具体概率\n\n```shell\n./guidance dinov2_vits14.cvimodel ILSVRC2012_val_00000094.JPEG\n```\n\n![测试结果](https://lc-gluttony.s3.amazonaws.com/6Beck3SuJkGW/vWYKcwiJrS8na1uYMrdCyXNpMRcfXQk1/Snipaste_2025-05-23_17-25-09.png \"测试结果\")\n"},{"title":"Spring AOP面向切面编程原理与实战详解","tags":["Spring","AOP","代理模式","系统设计"],"categories":["Spring"],"author":"Katyusha0x26d","excerpt":"\n最近在重构一个Spring Boot项目时，需要对所有接口添加统一的日志记录和性能监控，使用传统方式需要修改每个方法，工作量巨大且代码冗余。Spring AOP（面向切面编程）完美解决了这个问题，本文将深入剖析Spring AOP的使用方式和底层原理。\n\n","link":"/posts/spring-aop-deep-dive","content":"\n最近在重构一个Spring Boot项目时，需要对所有接口添加统一的日志记录和性能监控，使用传统方式需要修改每个方法，工作量巨大且代码冗余。Spring AOP（面向切面编程）完美解决了这个问题，本文将深入剖析Spring AOP的使用方式和底层原理。\n\n<!-- more -->\n\n## AOP基本概念\n\nAOP（Aspect-Oriented Programming，面向切面编程）是对OOP（面向对象编程）的补充，它将系统中的横切关注点（如日志、事务、权限等）从业务逻辑中分离出来，实现关注点分离。\n\n### 核心术语\n\n在深入Spring AOP之前，先理解几个核心概念：\n\n- **Aspect（切面）**：横切关注点的模块化，比如日志模块、事务管理模块\n- **Join Point（连接点）**：程序执行过程中的某个点，Spring AOP中特指方法执行\n- **Advice（通知）**：切面在特定连接点执行的动作，分为前置、后置、环绕、异常、最终通知\n- **Pointcut（切入点）**：匹配连接点的表达式，决定哪些方法需要被增强\n- **Target（目标对象）**：被AOP代理的原始对象\n- **Proxy（代理）**：AOP框架创建的对象，包含了原始对象的功能和增强功能\n- **Weaving（织入）**：将切面应用到目标对象创建代理对象的过程\n\n## Spring AOP快速上手\n\n### 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n### 基础使用示例\n\n创建一个简单的日志切面：\n\n```java\n@Aspect\n@Component\n@Slf4j\npublic class LoggingAspect {\n\n    // 定义切入点：匹配controller包下所有类的所有方法\n    @Pointcut(\"execution(* com.example.controller.*.*(..))\")\n    public void controllerMethods() {}\n\n    // 前置通知：方法执行前记录\n    @Before(\"controllerMethods()\")\n    public void logBefore(JoinPoint joinPoint) {\n        String methodName = joinPoint.getSignature().getName();\n        Object[] args = joinPoint.getArgs();\n        log.info(\"方法 {} 开始执行，参数：{}\", methodName, Arrays.toString(args));\n    }\n\n    // 后置返回通知：方法正常返回后\n    @AfterReturning(pointcut = \"controllerMethods()\", returning = \"result\")\n    public void logAfterReturning(JoinPoint joinPoint, Object result) {\n        String methodName = joinPoint.getSignature().getName();\n        log.info(\"方法 {} 执行完成，返回值：{}\", methodName, result);\n    }\n\n    // 异常通知：方法抛出异常时\n    @AfterThrowing(pointcut = \"controllerMethods()\", throwing = \"ex\")\n    public void logAfterThrowing(JoinPoint joinPoint, Exception ex) {\n        String methodName = joinPoint.getSignature().getName();\n        log.error(\"方法 {} 执行异常：{}\", methodName, ex.getMessage());\n    }\n}\n```\n\n### 环绕通知实现性能监控\n\n环绕通知是最强大的通知类型，可以完全控制方法的执行：\n\n```java\n@Aspect\n@Component\npublic class PerformanceAspect {\n\n    @Around(\"@annotation(com.example.annotation.MonitorPerformance)\")\n    public Object monitorPerformance(ProceedingJoinPoint pjp) throws Throwable {\n        long startTime = System.currentTimeMillis();\n\n        // 获取方法信息\n        String className = pjp.getTarget().getClass().getSimpleName();\n        String methodName = pjp.getSignature().getName();\n\n        try {\n            // 执行目标方法\n            Object result = pjp.proceed();\n\n            long elapsedTime = System.currentTimeMillis() - startTime;\n            if (elapsedTime > 1000) {\n                log.warn(\"{}.{} 执行时间过长：{}ms\", className, methodName, elapsedTime);\n            } else {\n                log.info(\"{}.{} 执行时间：{}ms\", className, methodName, elapsedTime);\n            }\n\n            return result;\n        } catch (Exception e) {\n            long elapsedTime = System.currentTimeMillis() - startTime;\n            log.error(\"{}.{} 执行异常，耗时：{}ms\", className, methodName, elapsedTime, e);\n            throw e;\n        }\n    }\n}\n```\n\n自定义注解：\n\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MonitorPerformance {\n    String value() default \"\";\n}\n```\n\n使用示例：\n\n```java\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping(\"/{id}\")\n    @MonitorPerformance\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n}\n```\n\n## 切入点表达式详解\n\nSpring AOP支持多种切入点表达式，最常用的是execution表达式：\n\n### execution表达式语法\n\n```text\nexecution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)\n```\n\n示例：\n\n```java\n// 匹配所有public方法\n@Pointcut(\"execution(public * *(..))\")\n\n// 匹配指定包下所有类的所有方法\n@Pointcut(\"execution(* com.example.service.*.*(..))\")\n\n// 匹配指定类的所有方法\n@Pointcut(\"execution(* com.example.service.UserService.*(..))\")\n\n// 匹配所有返回User类型的方法\n@Pointcut(\"execution(com.example.model.User *(..))\")\n\n// 匹配所有以save开头的方法\n@Pointcut(\"execution(* save*(..))\")\n\n// 匹配第一个参数为Long类型的方法\n@Pointcut(\"execution(* *(Long, ..))\")\n```\n\n### 其他切入点表达式\n\n```java\n@Aspect\n@Component\npublic class AdvancedPointcutAspect {\n\n    // within：匹配特定类型内的方法\n    @Pointcut(\"within(com.example.service.*)\")\n    public void inServiceLayer() {}\n\n    // @within：匹配标注了特定注解的类\n    @Pointcut(\"@within(org.springframework.stereotype.Service)\")\n    public void serviceAnnotated() {}\n\n    // @annotation：匹配标注了特定注解的方法\n    @Pointcut(\"@annotation(org.springframework.transaction.annotation.Transactional)\")\n    public void transactionalMethods() {}\n\n    // args：匹配特定参数类型\n    @Pointcut(\"args(String, Long)\")\n    public void stringLongArgs() {}\n\n    // @args：匹配参数标注了特定注解\n    @Pointcut(\"@args(com.example.annotation.Validated)\")\n    public void validatedArgs() {}\n\n    // bean：匹配特定名称的Bean\n    @Pointcut(\"bean(*Service)\")\n    public void serviceBeans() {}\n\n    // 组合切入点\n    @Pointcut(\"inServiceLayer() && transactionalMethods()\")\n    public void transactionalServiceMethods() {}\n}\n```\n\n## 实战案例\n\n### 统一异常处理与日志记录\n\n```java\n@Aspect\n@Component\n@Slf4j\npublic class ExceptionHandlingAspect {\n\n    @Around(\"@within(org.springframework.web.bind.annotation.RestController)\")\n    public Object handleException(ProceedingJoinPoint pjp) throws Throwable {\n        String methodName = pjp.getSignature().toShortString();\n\n        try {\n            return pjp.proceed();\n        } catch (BusinessException e) {\n            // 业务异常，记录警告日志\n            log.warn(\"业务异常 in {}: {}\", methodName, e.getMessage());\n            return ResponseEntity.badRequest().body(\n                Map.of(\"error\", e.getMessage(), \"code\", e.getCode())\n            );\n        } catch (Exception e) {\n            // 系统异常，记录错误日志\n            log.error(\"系统异常 in {}\", methodName, e);\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\n                Map.of(\"error\", \"系统内部错误\", \"code\", \"SYSTEM_ERROR\")\n            );\n        }\n    }\n}\n```\n\n### 方法级缓存实现\n\n```java\n@Aspect\n@Component\npublic class CachingAspect {\n\n    private final Map<String, Object> cache = new ConcurrentHashMap<>();\n\n    @Around(\"@annotation(cacheable)\")\n    public Object cache(ProceedingJoinPoint pjp, Cacheable cacheable) throws Throwable {\n        // 生成缓存key\n        String key = generateKey(pjp, cacheable.key());\n\n        // 检查缓存\n        if (cache.containsKey(key)) {\n            log.debug(\"缓存命中: {}\", key);\n            return cache.get(key);\n        }\n\n        // 执行方法\n        Object result = pjp.proceed();\n\n        // 存入缓存\n        if (result != null) {\n            cache.put(key, result);\n            log.debug(\"缓存存储: {}\", key);\n\n            // 设置过期（简化示例，实际应使用更完善的缓存方案）\n            if (cacheable.expire() > 0) {\n                scheduleEviction(key, cacheable.expire());\n            }\n        }\n\n        return result;\n    }\n\n    private String generateKey(ProceedingJoinPoint pjp, String keyExpression) {\n        if (StringUtils.hasText(keyExpression)) {\n            // 使用SpEL解析key表达式\n            return parseSpel(keyExpression, pjp);\n        }\n\n        // 默认使用类名+方法名+参数\n        return pjp.getTarget().getClass().getName() + \".\" +\n               pjp.getSignature().getName() +\n               Arrays.toString(pjp.getArgs());\n    }\n\n    private void scheduleEviction(String key, long seconds) {\n        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n        executor.schedule(() -> cache.remove(key), seconds, TimeUnit.SECONDS);\n    }\n}\n```\n\n### 分布式锁实现\n\n```java\n@Aspect\n@Component\npublic class DistributedLockAspect {\n\n    @Autowired\n    private RedissonClient redissonClient;\n\n    @Around(\"@annotation(distributedLock)\")\n    public Object lock(ProceedingJoinPoint pjp, DistributedLock distributedLock) throws Throwable {\n        String lockKey = resolveLockKey(pjp, distributedLock);\n        RLock lock = redissonClient.getLock(lockKey);\n\n        boolean acquired = false;\n        try {\n            // 尝试获取锁\n            acquired = lock.tryLock(\n                distributedLock.waitTime(),\n                distributedLock.leaseTime(),\n                TimeUnit.SECONDS\n            );\n\n            if (!acquired) {\n                throw new BusinessException(\"获取锁失败，请稍后重试\");\n            }\n\n            log.info(\"获取分布式锁成功: {}\", lockKey);\n            return pjp.proceed();\n\n        } finally {\n            if (acquired && lock.isHeldByCurrentThread()) {\n                lock.unlock();\n                log.info(\"释放分布式锁: {}\", lockKey);\n            }\n        }\n    }\n\n    private String resolveLockKey(ProceedingJoinPoint pjp, DistributedLock annotation) {\n        String key = annotation.key();\n        if (key.contains(\"#\")) {\n            // 解析SpEL表达式\n            return parseSpelKey(key, pjp);\n        }\n        return \"lock:\" + key;\n    }\n}\n```\n\n## Spring AOP原理\n\n### 代理模式基础\n\nSpring AOP基于代理模式实现，主要有两种代理方式：\n\n#### JDK动态代理\n\n适用于实现了接口的类：\n\n```java\npublic class JdkProxyExample {\n\n    interface UserService {\n        void save(String user);\n    }\n\n    static class UserServiceImpl implements UserService {\n        @Override\n        public void save(String user) {\n            System.out.println(\"保存用户: \" + user);\n        }\n    }\n\n    static class LoggingHandler implements InvocationHandler {\n        private final Object target;\n\n        public LoggingHandler(Object target) {\n            this.target = target;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            System.out.println(\"方法执行前: \" + method.getName());\n            Object result = method.invoke(target, args);\n            System.out.println(\"方法执行后: \" + method.getName());\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        UserService target = new UserServiceImpl();\n        UserService proxy = (UserService) Proxy.newProxyInstance(\n            target.getClass().getClassLoader(),\n            target.getClass().getInterfaces(),\n            new LoggingHandler(target)\n        );\n\n        proxy.save(\"张三\");\n    }\n}\n```\n\n#### CGLIB代理\n\n适用于没有实现接口的类：\n\n```java\npublic class CglibProxyExample {\n\n    static class UserService {\n        public void save(String user) {\n            System.out.println(\"保存用户: \" + user);\n        }\n    }\n\n    static class LoggingInterceptor implements MethodInterceptor {\n        @Override\n        public Object intercept(Object obj, Method method, Object[] args,\n                              MethodProxy proxy) throws Throwable {\n            System.out.println(\"方法执行前: \" + method.getName());\n            Object result = proxy.invokeSuper(obj, args);\n            System.out.println(\"方法执行后: \" + method.getName());\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(UserService.class);\n        enhancer.setCallback(new LoggingInterceptor());\n\n        UserService proxy = (UserService) enhancer.create();\n        proxy.save(\"李四\");\n    }\n}\n```\n\n### Spring AOP代理创建流程\n\nSpring通过`DefaultAopProxyFactory`决定使用哪种代理方式：\n\n```java\npublic class DefaultAopProxyFactory implements AopProxyFactory {\n\n    @Override\n    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n        // 如果满足以下条件之一，使用CGLIB代理：\n        // 1. 配置强制使用CGLIB（proxy-target-class=true）\n        // 2. 目标类没有实现接口\n        // 3. 只代理了SpringProxy接口\n        if (config.isOptimize() || config.isProxyTargetClass() ||\n            hasNoUserSuppliedProxyInterfaces(config)) {\n\n            Class<?> targetClass = config.getTargetClass();\n            if (targetClass == null) {\n                throw new AopConfigException(\"TargetSource cannot determine target class\");\n            }\n\n            // 如果目标类是接口或者是代理类，使用JDK代理\n            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n                return new JdkDynamicAopProxy(config);\n            }\n\n            // 使用CGLIB代理\n            return new ObjenesisCglibAopProxy(config);\n        } else {\n            // 使用JDK代理\n            return new JdkDynamicAopProxy(config);\n        }\n    }\n}\n```\n\n### @AspectJ注解处理流程\n\nSpring容器启动时，`AnnotationAwareAspectJAutoProxyCreator`负责处理@AspectJ注解：\n\n```java\npublic class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator {\n\n    @Override\n    protected List<Advisor> findCandidateAdvisors() {\n        // 调用父类方法查找所有Advisor\n        List<Advisor> advisors = super.findCandidateAdvisors();\n\n        // 查找@AspectJ注解的切面\n        if (this.aspectJAdvisorsBuilder != null) {\n            advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());\n        }\n\n        return advisors;\n    }\n\n    // 构建切面通知\n    public List<Advisor> buildAspectJAdvisors() {\n        List<String> aspectNames = this.aspectBeanNames;\n\n        if (aspectNames == null) {\n            synchronized (this) {\n                aspectNames = this.aspectBeanNames;\n                if (aspectNames == null) {\n                    List<Advisor> advisors = new ArrayList<>();\n                    aspectNames = new ArrayList<>();\n\n                    // 获取所有Bean名称\n                    String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                        this.beanFactory, Object.class, true, false);\n\n                    for (String beanName : beanNames) {\n                        Class<?> beanType = this.beanFactory.getType(beanName);\n\n                        // 判断是否为@Aspect注解的类\n                        if (this.advisorFactory.isAspect(beanType)) {\n                            aspectNames.add(beanName);\n\n                            // 获取切面元数据\n                            AspectMetadata amd = new AspectMetadata(beanType, beanName);\n\n                            // 创建Advisor\n                            List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(\n                                new BeanFactoryAspectInstanceFactory(\n                                    this.beanFactory, beanName));\n\n                            advisors.addAll(classAdvisors);\n                        }\n                    }\n\n                    this.aspectBeanNames = aspectNames;\n                    return advisors;\n                }\n            }\n        }\n\n        return Collections.emptyList();\n    }\n}\n```\n\n### 通知执行链\n\n当代理对象的方法被调用时，会构建一个拦截器链：\n\n```java\npublic class ReflectiveMethodInvocation implements ProxyMethodInvocation {\n\n    protected final Object proxy;\n    protected final Object target;\n    protected final Method method;\n    protected Object[] arguments;\n    protected final List<?> interceptorsAndDynamicMethodMatchers;\n    private int currentInterceptorIndex = -1;\n\n    @Override\n    public Object proceed() throws Throwable {\n        // 所有拦截器执行完毕，执行目标方法\n        if (this.currentInterceptorIndex ==\n            this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n            return invokeJoinpoint();\n        }\n\n        // 获取下一个拦截器\n        Object interceptorOrInterceptionAdvice =\n            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n\n        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n            // 动态匹配\n            InterceptorAndDynamicMethodMatcher dm =\n                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n\n            if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n                return dm.interceptor.invoke(this);\n            } else {\n                // 跳过不匹配的拦截器\n                return proceed();\n            }\n        } else {\n            // 执行拦截器\n            return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n        }\n    }\n}\n```\n\n## 性能优化\n\n### 合理使用切入点表达式\n\n```java\n// 不推荐：范围太广\n@Pointcut(\"execution(* *(..))\")\n\n// 推荐：精确匹配\n@Pointcut(\"execution(* com.example.service.*Service.*(..))\")\n```\n\n### 避免在通知中执行耗时操作\n\n```java\n@Aspect\n@Component\npublic class AsyncLoggingAspect {\n\n    @Autowired\n    private AsyncTaskExecutor taskExecutor;\n\n    @AfterReturning(\"@annotation(Loggable)\")\n    public void logAsync(JoinPoint joinPoint) {\n        // 异步执行耗时操作\n        taskExecutor.execute(() -> {\n            // 耗时的日志处理\n            processLog(joinPoint);\n        });\n    }\n}\n```\n\n### 使用编译时织入提升性能\n\n对于性能敏感的场景，可以使用AspectJ编译时织入（CTW）或加载时织入（LTW）：\n\n```xml\n<!-- 启用AspectJ编译时织入 -->\n<plugin>\n    <groupId>org.codehaus.mojo</groupId>\n    <artifactId>aspectj-maven-plugin</artifactId>\n    <version>1.14.0</version>\n    <configuration>\n        <complianceLevel>11</complianceLevel>\n        <source>11</source>\n        <target>11</target>\n        <showWeaveInfo>true</showWeaveInfo>\n        <aspectLibraries>\n            <aspectLibrary>\n                <groupId>org.springframework</groupId>\n                <artifactId>spring-aspects</artifactId>\n            </aspectLibrary>\n        </aspectLibraries>\n    </configuration>\n    <executions>\n        <execution>\n            <goals>\n                <goal>compile</goal>\n            </goals>\n        </execution>\n    </executions>\n</plugin>\n```\n\n## 常见问题与解决方案\n\n### 自调用失效问题\n\n```java\n@Service\npublic class UserService {\n\n    @Transactional\n    public void saveUser(User user) {\n        // 直接调用本类方法，AOP不生效\n        sendNotification(user); // 错误！\n\n        // 正确方式1：注入自身代理\n        ((UserService) AopContext.currentProxy()).sendNotification(user);\n\n        // 正确方式2：将方法移到其他类\n    }\n\n    @Async\n    public void sendNotification(User user) {\n        // 发送通知\n    }\n}\n\n// 启用暴露代理\n@EnableAspectJAutoProxy(exposeProxy = true)\n```\n\n### final方法和类的问题\n\nCGLIB无法代理final方法和final类：\n\n```java\n// 错误：final类无法被CGLIB代理\n@Service\npublic final class UserService {\n    // ...\n}\n\n// 错误：final方法无法被增强\n@Service\npublic class UserService {\n    public final void save() {\n        // ...\n    }\n}\n```\n\n### 切面执行顺序\n\n使用@Order注解控制多个切面的执行顺序：\n\n```java\n@Aspect\n@Component\n@Order(1) // 数字越小，优先级越高\npublic class SecurityAspect {\n    // 安全检查\n}\n\n@Aspect\n@Component\n@Order(2)\npublic class LoggingAspect {\n    // 日志记录\n}\n\n@Aspect\n@Component\n@Order(3)\npublic class CachingAspect {\n    // 缓存处理\n}\n```\n\n## 写在最后\n\nAOP适合处理那些与业务逻辑正交的横切关注点，对于核心业务逻辑，还是应该使用传统的OOP方式来组织代码。\n"},{"title":"Web后端服务身份认证方案汇总与个人思考","tags":["Web","认证","系统设计"],"categories":["认证授权"],"author":"Katyusha0x26d","excerpt":"\n最近在编写一个Spring Boot后端项目，需要处理用户身份认证，遂撰写此文总结一下基本的Web后端服务身份认证方案。\n\n","link":"/posts/web-authentication-methods","content":"\n最近在编写一个Spring Boot后端项目，需要处理用户身份认证，遂撰写此文总结一下基本的Web后端服务身份认证方案。\n\n<!-- more -->\n\n## HTTP基本验证\n\n直接设置HTTP请求头`Authorization`，在其中插入加密的密码，例如：\n\n```text\nAuthorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\n```\n\n显然，`Basic`后面一串是Base64加密过的密码\n\n优点：无状态，实现简单，后端对请求头解密，查询数据库验证即可判断用户请求是否合法\n\n缺点也很明显，对密码没有任何保护，如果没有使用加密或者使用了弱加密，又或者加密密钥泄露，问题就大了\n\n详细参考：[IETF RFC 7617, The 'Basic' HTTP Authentication Scheme](https://datatracker.ietf.org/doc/html/rfc7617)\n\n## Cookie-Session身份认证\n\n这应该是目前最常见的身份认证方案了吧，用户登录后，服务器验证身份并保存登录状态在服务器端的Session中，同时将Session ID放入Cookie发送给客户端。客户端在后续请求中自动带上该Cookie，服务器根据Cookie中的Session ID查询对应的Session，验证用户身份\n\nSpring Boot后端示例：\n\n```java\n@RestController\npublic class UserAuthController {\n\n    @PostMapping(\"/login\")\n    public ResponseEntity<String> login(@RequestParam String username, @RequestParam String password, HttpSession session) {\n        // 验证用户名密码示例\n        if (\"user\".equals(username) && \"password\".equals(password)) {\n            session.setAttribute(\"user\", username);  // 保存登录状态\n            return ResponseEntity.ok(\"登录成功\");\n        }\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(\"登录失败\");\n    }\n\n    @GetMapping(\"/profile\")\n    public ResponseEntity<String> profile(HttpSession session) {\n        String user = (String) session.getAttribute(\"user\");\n        if (user != null) {\n            return ResponseEntity.ok(\"当前用户：\" + user);\n        }\n        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(\"未登录\");\n    }\n\n    @PostMapping(\"/logout\")\n    public ResponseEntity<String> logout(HttpSession session) {\n        session.invalidate(); // 注销Session\n        return ResponseEntity.ok(\"已退出登录\");\n    }\n}\n```\n\nPOST /login接口并带上正确的参数时，响应头为：`Set-Cookie: JSESSIONID=8A98AA17F3EDAF7E06D1363466EF69E4; Path=/; HttpOnly; Secure; SameSite=Strict`，后续请求浏览器将会自动带上这个cookie\n\n优点：实现简单，技术成熟，与前述基本认证相比更安全\n\n缺点：有状态，容易受到CSRF攻击，在多台机器之间session无法同步\n\n改进多台服务器之间的session同步问题：使用独立出来的、所有机器都可以访问的Redis缓存！在Spring Boot上，可以直接使用Spring Session改进\n\n那么，又一个问题来了，在客户端禁用Cookie的情况下如何处理session？\n\n现代的很多网站不仅仅使用cookie存储会话数据，还进行跨站信息共享等，对于用户隐私是极大的威胁，因此一些浏览器或者浏览器插件可以禁用cookie，这种情况下，可以考虑在后续请求中，将会话ID放置于URL参数中解决\n\n有关前端防止CSRF攻击，请参考：[前端安全系列（二）：如何防止CSRF攻击？](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)\n\n## token身份认证\n\ntoken身份认证与上述Cookie-Session身份认证思想类似，区别在于服务器将会话ID以其它方式传输或者存储，例如将会话ID放置于请求体中返回给前端，随后前端将会话ID存储于localStorage，在后续请求中手动带上\n\n一种token身份认证的实现方案如下，为了解决分布式问题，服务端将会话ID存储于redis中：\n\n引入依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n```\n\n```java\n@Service\npublic class TokenService {\n\n    private final String TOKEN_PREFIX = \"AUTH_TOKEN:\";\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n\n    // 生成Token并存储用户信息，设置过期时间（如30分钟）\n    public String createToken(String username) {\n        String token = UUID.randomUUID().toString();\n        redisTemplate.opsForValue().set(TOKEN_PREFIX + token, username, 30, TimeUnit.MINUTES);\n        return token;\n    }\n\n    // 根据Token取出用户名\n    public String getUsername(String token) {\n        return redisTemplate.opsForValue().get(TOKEN_PREFIX + token);\n    }\n\n    // 删除Token\n    public void deleteToken(String token) {\n        redisTemplate.delete(TOKEN_PREFIX + token);\n    }\n\n    // 验证Token（存在且未过期）\n    public boolean isValid(String token) {\n        return redisTemplate.hasKey(TOKEN_PREFIX + token);\n    }\n}\n\n```\n\n身份认证过滤器，直接使用Spring Security演示\n\n```java\n@Component\npublic class TokenAuthenticationFilter extends OncePerRequestFilter {\n    @Autowired\n    private TokenService tokenService;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain filterChain) throws ServletException, IOException {\n        String token = request.getHeader(\"Authorization\");\n        if (token != null && token.startsWith(\"Bearer \")) {\n            token = token.substring(7);\n            if (tokenService.isValid(token)) {\n                String username = tokenService.getUsername(token);\n                // 这里简单演示，设置认证上下文为通过身份校验\n                UsernamePasswordAuthenticationToken auth =\n                    new UsernamePasswordAuthenticationToken(username, null, new ArrayList<>());\n                SecurityContextHolder.getContext().setAuthentication(auth);\n            }\n        }\n        filterChain.doFilter(request, response);\n    }\n}\n\n```\n\nSpring Security配置：\n\n```java\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Autowired\n    private TokenAuthenticationFilter tokenAuthenticationFilter;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable()\n            .authorizeRequests()\n            .antMatchers(\"/login\").permitAll()\n            .anyRequest().authenticated();\n        http.addFilterBefore(tokenAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\n    }\n}\n\n```\n\n控制器层：\n\n```java\n@RestController\npublic class AuthController {\n    @Autowired\n    private TokenService tokenService;\n\n    @PostMapping(\"/login\")\n    public ResponseEntity<?> login(@RequestParam String username, @RequestParam String password) {\n        // 这里简单模拟验证用户名密码，实际应查数据库或其他用户存储\n        if (\"user\".equals(username) && \"pass\".equals(password)) {\n            String token = tokenService.createToken(username);\n            Map<String, String> result = new HashMap<>();\n            result.put(\"token\", token);\n            return ResponseEntity.ok(result);\n        } else {\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(\"Invalid credentials\");\n        }\n    }\n\n    // 可选登出，删除Token\n    @PostMapping(\"/logout\")\n    public ResponseEntity<?> logout(@RequestHeader(\"Authorization\") String auth) {\n        if (auth != null && auth.startsWith(\"Bearer \")) {\n            String token = auth.substring(7);\n            tokenService.deleteToken(token);\n        }\n        return ResponseEntity.ok(\"Logged out\");\n    }\n}\n\n```\n\n前端AXIOS示例：\n\n```typescript\nimport axios from \"axios\";\n\nconst api = axios.create({\n  baseURL: \"http://localhost:8080\",\n});\n\n// 登录函数\nexport async function login(username: string, password: string): Promise<string> {\n  const response = await api.post(\"/login\", null, {\n    params: { username, password },\n  });\n  return response.data.token;\n}\n\n// 设置请求拦截器，自动带上Token\nexport function setAuthToken(token: string | null) {\n  if (token) {\n    api.defaults.headers.common[\"Authorization\"] = `Bearer ${token}`;\n  } else {\n    delete api.defaults.headers.common[\"Authorization\"];\n  }\n}\n\n// 示例调用，登录并请求用户信息\nasync function example() {\n  try {\n    const token = await login(\"user\", \"pass\");\n    console.log(\"Token:\", token);\n\n    setAuthToken(token);\n\n    // 带Token请求受保护接口\n    const userInfo = await api.get(\"/user\");\n    console.log(\"User info:\", userInfo.data);\n  } catch (err) {\n    console.error(\"登录或请求失败\", err);\n  }\n}\n\n// 调用示例\nexample();\n\n```\n\n存储于localStorage而不是Cookie的最大优势在于避免CSRF攻击\n\n## JWT身份认证\n\nJWT即JSON Web Token，本质上是升级版+阉割版的token身份认证，具体流程为：\n\n1. 客户端请求登录接口，带上正确的用户凭据\n2. 服务端验证凭据，将一个“证明文件”颁发给用户\n3. 这个“证明文件”的颁发方案：一般对用户ID等重要信息使用服务端的私钥签名，指定过期时间并转为JWT格式\n4. 后续请求中，客户端带上JWT，服务端验证签名和过期时间，并从“证明文件”中取出之前指定的用户ID\n\n注意，上述操作不涉及加密部分，JWT也都是明文的，例如：\n\n```text\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30\n```\n\n将payload部分转为JSON格式：\n\n```json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true,\n  \"iat\": 1516239022\n}\n```\n\n有一些读者可能会奇怪，JWT是明文的，又如何保证JWT不被客户端篡改？\n\n答案是服务器中对比JWT签名即可，非对称加密中，私钥签名后使用公钥只能验证签名，不能重新签名\n\nJWT实现示例，首先引入依赖：\n\n```xml\n<dependency>\n    <groupId>io.jsonwebtoken</groupId>\n    <artifactId>jjwt</artifactId>\n    <version>0.12.6</version>\n</dependency>\n```\n\n编写JWT工具类：\n\n```java\nimport io.jsonwebtoken.*;\nimport io.jsonwebtoken.security.Keys;\n\nimport javax.crypto.SecretKey;\nimport java.util.Date;\n\npublic class JwtUtil {\n\n    // 生成一个安全的SecretKey（同一应用应存储复用）\n    private static final SecretKey SECRET_KEY = Keys.secretKeyFor(SignatureAlgorithm.HS256);\n\n    // 过期时间 (例如1小时)\n    private static final long EXPIRATION_MILLIS = 3600000;\n\n    // 生成JWT Token\n    public static String generateToken(String username) {\n        long nowMillis = System.currentTimeMillis();\n\n        return Jwts.builder()\n                .setSubject(username)               // JWT主题，一般放用户名或用户ID\n                .setIssuedAt(new Date(nowMillis))  // 签发时间\n                .setExpiration(new Date(nowMillis + EXPIRATION_MILLIS)) // 过期时间\n                .signWith(SECRET_KEY)               // 签名算法和密钥\n                .compact();\n    }\n\n    // 解析并验证JWT Token，返回主题（用户名）\n    public static String validateTokenAndGetUsername(String token) {\n        try {\n            Jws<Claims> jwsClaims = Jwts.parserBuilder()\n                    .setSigningKey(SECRET_KEY)\n                    .build()\n                    .parseClaimsJws(token);\n\n            return jwsClaims.getBody().getSubject();\n\n        } catch (JwtException e) {\n            // 如果token无效、过期或签名错误则抛异常，可捕获做相应处理\n            throw new RuntimeException(\"Invalid or expired JWT token\");\n        }\n    }\n}\n\n```\n\n控制器层：\n\n```java\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@RestController\npublic class AuthController {\n\n    @PostMapping(\"/login\")\n    public Map<String, String> login(@RequestParam String username, @RequestParam String password) {\n        // 模拟验证用户名密码\n        if (\"user\".equals(username) && \"pass\".equals(password)) {\n            String token = JwtUtil.generateToken(username);\n            Map<String, String> result = new HashMap<>();\n            result.put(\"token\", token);\n            return result;\n        } else {\n            throw new RuntimeException(\"Invalid credentials\");\n        }\n    }\n\n    @GetMapping(\"/protected\")\n    public String protectedResource(@RequestHeader(\"Authorization\") String authHeader) {\n        // 通过Authorization头获取token（格式: Bearer eyJ...）\n        if (authHeader == null || !authHeader.startsWith(\"Bearer \")) {\n            throw new RuntimeException(\"Missing or invalid Authorization header\");\n        }\n        String token = authHeader.substring(7);\n        String username = JwtUtil.validateTokenAndGetUsername(token);\n\n        return \"Hello, \" + username + \". This is a protected resource.\";\n    }\n}\n\n```\n\nJWT方案的优点很显然，身份认证服务无状态，服务器不需要保存用户会话信息\n\n但是缺点也很多，不支持注销会话，只要JWT还在有效期内就可以通过认证\n\n解决方案一般有：\n\n1. 对于修改密码时的注销问题，可以使用用户密码的hash（因为一般服务器不存储明文密码）作为JWT的签名\n2. 对于单独注销会话的问题，可以在数据库中保存一个会话版本号，用户需要注销时，自增该版本号，在后续认证时，也会验证版本号是否正确\n\n然而，即使做出上述修改，仍然无法解决一些时候，用户有很多会话，但是只想注销其中一个会话的情景，这个无解，毕竟JWT无状态，服务端并不存储会话信息，如果为了安全性想要支持该过程，可以考虑转为使用前面的基本TOKEN身份认证\n\n## 其它身份认证方案\n\n此外也有OAuth、TOTP等，无非是前文的扩展，先鸽了，等后面单独出几篇文章详细说明\n"},{"title":"Web后端服务授权控制方案汇总与个人思考","tags":["Web","授权","系统设计"],"categories":["认证授权"],"author":"Katyusha0x26d","excerpt":"\n在完成用户身份认证后，如何控制用户能访问哪些资源、执行哪些操作？这就是授权（Authorization）要解决的问题。本文将详细介绍RBAC、ABAC和Spring Security的SpEL权限验证等主流授权方案的原理与实现。\n\n","link":"/posts/web-authorization-methods","content":"\n在完成用户身份认证后，如何控制用户能访问哪些资源、执行哪些操作？这就是授权（Authorization）要解决的问题。本文将详细介绍RBAC、ABAC和Spring Security的SpEL权限验证等主流授权方案的原理与实现。\n\n<!-- more -->\n\n## RBAC权限模型\n\nRBAC（Role-Based Access Control，基于角色的访问控制）是目前应用最广泛的权限模型。用户通过角色与权限进行关联，简化了权限管理的复杂度。\n\n### RBAC0：基础模型\n\n最基础的RBAC模型包含三个核心概念：\n- **用户（User）**：系统的使用者\n- **角色（Role）**：权限的集合\n- **权限（Permission）**：对资源的操作许可\n\n数据库设计：\n\n```sql\n-- 用户表\nCREATE TABLE users (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    username VARCHAR(50) NOT NULL UNIQUE,\n    password VARCHAR(255) NOT NULL,\n    email VARCHAR(100),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- 角色表\nCREATE TABLE roles (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(50) NOT NULL UNIQUE,\n    description VARCHAR(255),\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- 权限表\nCREATE TABLE permissions (\n    id BIGINT PRIMARY KEY AUTO_INCREMENT,\n    name VARCHAR(100) NOT NULL UNIQUE,\n    resource VARCHAR(100) NOT NULL,  -- 资源类型\n    action VARCHAR(50) NOT NULL,     -- 操作类型\n    description VARCHAR(255)\n);\n\n-- 用户-角色关联表\nCREATE TABLE user_roles (\n    user_id BIGINT NOT NULL,\n    role_id BIGINT NOT NULL,\n    PRIMARY KEY (user_id, role_id),\n    FOREIGN KEY (user_id) REFERENCES users(id),\n    FOREIGN KEY (role_id) REFERENCES roles(id)\n);\n\n-- 角色-权限关联表\nCREATE TABLE role_permissions (\n    role_id BIGINT NOT NULL,\n    permission_id BIGINT NOT NULL,\n    PRIMARY KEY (role_id, permission_id),\n    FOREIGN KEY (role_id) REFERENCES roles(id),\n    FOREIGN KEY (permission_id) REFERENCES permissions(id)\n);\n```\n\nSpring Boot实现：\n\n```java\n@Service\npublic class RbacService {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private RoleRepository roleRepository;\n\n    @Autowired\n    private PermissionRepository permissionRepository;\n\n    // 获取用户所有权限\n    public Set<String> getUserPermissions(Long userId) {\n        User user = userRepository.findById(userId)\n            .orElseThrow(() -> new NotFoundException(\"用户不存在\"));\n\n        Set<String> permissions = new HashSet<>();\n        for (Role role : user.getRoles()) {\n            for (Permission permission : role.getPermissions()) {\n                permissions.add(permission.getName());\n            }\n        }\n        return permissions;\n    }\n\n    // 检查用户是否有特定权限\n    public boolean hasPermission(Long userId, String resource, String action) {\n        Set<String> permissions = getUserPermissions(userId);\n        String permissionName = resource + \":\" + action;\n        return permissions.contains(permissionName);\n    }\n\n    // 给用户分配角色\n    @Transactional\n    public void assignRole(Long userId, Long roleId) {\n        User user = userRepository.findById(userId)\n            .orElseThrow(() -> new NotFoundException(\"用户不存在\"));\n        Role role = roleRepository.findById(roleId)\n            .orElseThrow(() -> new NotFoundException(\"角色不存在\"));\n\n        user.getRoles().add(role);\n        userRepository.save(user);\n    }\n}\n```\n\n自定义权限注解：\n\n```java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RequirePermission {\n    String resource();\n    String action();\n}\n\n@Aspect\n@Component\npublic class PermissionAspect {\n\n    @Autowired\n    private RbacService rbacService;\n\n    @Autowired\n    private HttpServletRequest request;\n\n    @Around(\"@annotation(requirePermission)\")\n    public Object checkPermission(ProceedingJoinPoint pjp,\n                                 RequirePermission requirePermission) throws Throwable {\n        // 从请求中获取用户ID（通常从JWT或Session中获取）\n        Long userId = getCurrentUserId();\n\n        if (!rbacService.hasPermission(userId,\n                                      requirePermission.resource(),\n                                      requirePermission.action())) {\n            throw new AccessDeniedException(\"权限不足\");\n        }\n\n        return pjp.proceed();\n    }\n\n    private Long getCurrentUserId() {\n        // 从认证信息中获取用户ID\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n        if (auth != null && auth.getPrincipal() instanceof UserDetails) {\n            return ((CustomUserDetails) auth.getPrincipal()).getUserId();\n        }\n        throw new UnauthorizedException(\"用户未登录\");\n    }\n}\n```\n\n使用示例：\n\n```java\n@RestController\n@RequestMapping(\"/api/articles\")\npublic class ArticleController {\n\n    @PostMapping\n    @RequirePermission(resource = \"article\", action = \"create\")\n    public Article createArticle(@RequestBody ArticleDto dto) {\n        // 创建文章逻辑\n        return articleService.create(dto);\n    }\n\n    @DeleteMapping(\"/{id}\")\n    @RequirePermission(resource = \"article\", action = \"delete\")\n    public void deleteArticle(@PathVariable Long id) {\n        articleService.delete(id);\n    }\n}\n```\n\n### RBAC1：角色继承\n\nRBAC1在RBAC0基础上增加了角色继承机制，子角色可以继承父角色的所有权限：\n\n```sql\n-- 角色继承表\nCREATE TABLE role_hierarchy (\n    parent_role_id BIGINT NOT NULL,\n    child_role_id BIGINT NOT NULL,\n    PRIMARY KEY (parent_role_id, child_role_id),\n    FOREIGN KEY (parent_role_id) REFERENCES roles(id),\n    FOREIGN KEY (child_role_id) REFERENCES roles(id)\n);\n```\n\n递归查询角色权限：\n\n```java\n@Service\npublic class HierarchicalRbacService extends RbacService {\n\n    // 获取角色及其所有父角色的权限\n    public Set<Permission> getRolePermissionsWithHierarchy(Long roleId) {\n        Set<Permission> permissions = new HashSet<>();\n        Set<Long> visitedRoles = new HashSet<>();\n\n        collectPermissions(roleId, permissions, visitedRoles);\n        return permissions;\n    }\n\n    private void collectPermissions(Long roleId,\n                                   Set<Permission> permissions,\n                                   Set<Long> visitedRoles) {\n        if (visitedRoles.contains(roleId)) {\n            return; // 避免循环引用\n        }\n        visitedRoles.add(roleId);\n\n        Role role = roleRepository.findById(roleId).orElse(null);\n        if (role == null) {\n            return;\n        }\n\n        // 添加当前角色的权限\n        permissions.addAll(role.getPermissions());\n\n        // 递归获取父角色的权限\n        List<Role> parentRoles = roleRepository.findParentRoles(roleId);\n        for (Role parentRole : parentRoles) {\n            collectPermissions(parentRole.getId(), permissions, visitedRoles);\n        }\n    }\n}\n```\n\n### RBAC2：角色约束\n\nRBAC2引入了角色约束，包括互斥角色、角色数量限制、先决条件角色等：\n\n```java\n@Component\npublic class RoleConstraintValidator {\n\n    @Autowired\n    private RoleConstraintRepository constraintRepository;\n\n    // 检查互斥角色\n    public boolean checkMutualExclusion(Long userId, Long newRoleId) {\n        User user = userRepository.findById(userId).orElse(null);\n        if (user == null) return false;\n\n        Set<Long> userRoleIds = user.getRoles().stream()\n            .map(Role::getId)\n            .collect(Collectors.toSet());\n\n        // 查询与新角色互斥的所有角色\n        List<Long> mutuallyExclusiveRoles =\n            constraintRepository.findMutuallyExclusiveRoles(newRoleId);\n\n        // 检查用户是否已有互斥角色\n        return Collections.disjoint(userRoleIds, mutuallyExclusiveRoles);\n    }\n\n    // 检查角色数量限制\n    public boolean checkRoleLimit(Long userId, String roleType) {\n        int currentCount = roleRepository.countUserRolesByType(userId, roleType);\n        int maxLimit = constraintRepository.getMaxRoleLimit(roleType);\n        return currentCount < maxLimit;\n    }\n\n    // 检查先决条件角色\n    public boolean checkPrerequisites(Long userId, Long roleId) {\n        List<Long> prerequisiteRoles =\n            constraintRepository.findPrerequisiteRoles(roleId);\n\n        if (prerequisiteRoles.isEmpty()) {\n            return true;\n        }\n\n        Set<Long> userRoleIds = userRepository.findById(userId)\n            .map(user -> user.getRoles().stream()\n                .map(Role::getId)\n                .collect(Collectors.toSet()))\n            .orElse(Collections.emptySet());\n\n        return userRoleIds.containsAll(prerequisiteRoles);\n    }\n}\n```\n\n### RBAC3：RBAC1 + RBAC2\n\nRBAC3结合了角色继承和角色约束，是最完整的RBAC模型。\n\n完整的权限检查服务：\n\n```java\n@Service\npublic class CompleteRbacService {\n\n    @Autowired\n    private HierarchicalRbacService hierarchicalRbacService;\n\n    @Autowired\n    private RoleConstraintValidator constraintValidator;\n\n    @Transactional\n    public void assignRoleWithValidation(Long userId, Long roleId) {\n        // 1. 检查互斥约束\n        if (!constraintValidator.checkMutualExclusion(userId, roleId)) {\n            throw new BusinessException(\"角色互斥，无法分配\");\n        }\n\n        // 2. 检查数量限制\n        Role role = roleRepository.findById(roleId).orElse(null);\n        if (role != null && !constraintValidator.checkRoleLimit(userId, role.getType())) {\n            throw new BusinessException(\"超过角色数量限制\");\n        }\n\n        // 3. 检查先决条件\n        if (!constraintValidator.checkPrerequisites(userId, roleId)) {\n            throw new BusinessException(\"缺少必要的前置角色\");\n        }\n\n        // 4. 分配角色\n        assignRole(userId, roleId);\n    }\n\n    // 获取用户的有效权限（考虑继承）\n    public Set<String> getEffectivePermissions(Long userId) {\n        User user = userRepository.findById(userId).orElse(null);\n        if (user == null) return Collections.emptySet();\n\n        Set<Permission> allPermissions = new HashSet<>();\n        for (Role role : user.getRoles()) {\n            allPermissions.addAll(\n                hierarchicalRbacService.getRolePermissionsWithHierarchy(role.getId())\n            );\n        }\n\n        return allPermissions.stream()\n            .map(p -> p.getResource() + \":\" + p.getAction())\n            .collect(Collectors.toSet());\n    }\n}\n```\n\n## ABAC权限模型\n\nABAC（Attribute-Based Access Control，基于属性的访问控制）通过属性来进行权限判断，比RBAC更加灵活细粒度。\n\n### ABAC核心概念\n\n- **主体属性（Subject Attributes）**：用户的属性，如部门、职位、等级\n- **资源属性（Resource Attributes）**：资源的属性，如创建者、分类、敏感级别\n- **环境属性（Environment Attributes）**：环境属性，如时间、地点、IP地址\n- **操作属性（Action Attributes）**：操作类型，如读、写、删除\n\n### 策略定义与存储\n\n```java\n@Entity\npublic class AbacPolicy {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n    private String description;\n\n    @Column(columnDefinition = \"TEXT\")\n    private String rule; // 使用JSON或表达式存储规则\n\n    private Integer priority; // 优先级\n    private Boolean enabled;\n\n    @Enumerated(EnumType.STRING)\n    private PolicyEffect effect; // PERMIT or DENY\n}\n\npublic enum PolicyEffect {\n    PERMIT, DENY\n}\n```\n\n策略规则示例（JSON格式）：\n\n```json\n{\n  \"name\": \"部门文档访问策略\",\n  \"conditions\": {\n    \"all\": [\n      {\n        \"fact\": \"subject\",\n        \"path\": \"$.department\",\n        \"operator\": \"equal\",\n        \"value\": {\n          \"fact\": \"resource\",\n          \"path\": \"$.department\"\n        }\n      },\n      {\n        \"any\": [\n          {\n            \"fact\": \"subject\",\n            \"path\": \"$.role\",\n            \"operator\": \"in\",\n            \"value\": [\"manager\", \"admin\"]\n          },\n          {\n            \"fact\": \"resource\",\n            \"path\": \"$.owner\",\n            \"operator\": \"equal\",\n            \"value\": {\n              \"fact\": \"subject\",\n              \"path\": \"$.id\"\n            }\n          }\n        ]\n      }\n    ]\n  },\n  \"effect\": \"PERMIT\"\n}\n```\n\n### ABAC引擎实现\n\n```java\n@Service\npublic class AbacEngine {\n\n    @Autowired\n    private PolicyRepository policyRepository;\n\n    @Autowired\n    private ScriptEngine scriptEngine;\n\n    public boolean evaluate(AbacContext context) {\n        List<AbacPolicy> policies = policyRepository.findEnabledPolicies();\n\n        // 按优先级排序\n        policies.sort(Comparator.comparing(AbacPolicy::getPriority));\n\n        for (AbacPolicy policy : policies) {\n            PolicyResult result = evaluatePolicy(policy, context);\n\n            if (result == PolicyResult.DENY) {\n                return false; // 拒绝优先\n            }\n            if (result == PolicyResult.PERMIT) {\n                return true;\n            }\n        }\n\n        // 默认拒绝\n        return false;\n    }\n\n    private PolicyResult evaluatePolicy(AbacPolicy policy, AbacContext context) {\n        try {\n            // 使用JavaScript引擎评估规则\n            scriptEngine.put(\"subject\", context.getSubject());\n            scriptEngine.put(\"resource\", context.getResource());\n            scriptEngine.put(\"action\", context.getAction());\n            scriptEngine.put(\"environment\", context.getEnvironment());\n\n            Boolean result = (Boolean) scriptEngine.eval(policy.getRule());\n\n            if (result) {\n                return policy.getEffect() == PolicyEffect.PERMIT ?\n                    PolicyResult.PERMIT : PolicyResult.DENY;\n            }\n\n            return PolicyResult.NOT_APPLICABLE;\n\n        } catch (Exception e) {\n            log.error(\"策略评估失败: {}\", policy.getName(), e);\n            return PolicyResult.NOT_APPLICABLE;\n        }\n    }\n}\n\n@Data\npublic class AbacContext {\n    private Map<String, Object> subject;    // 主体属性\n    private Map<String, Object> resource;   // 资源属性\n    private Map<String, Object> action;     // 操作属性\n    private Map<String, Object> environment; // 环境属性\n}\n```\n\n### 动态属性获取\n\n```java\n@Component\npublic class AttributeResolver {\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private ResourceService resourceService;\n\n    public AbacContext buildContext(Long userId, Long resourceId, String action) {\n        AbacContext context = new AbacContext();\n\n        // 解析主体属性\n        User user = userService.findById(userId);\n        Map<String, Object> subjectAttrs = new HashMap<>();\n        subjectAttrs.put(\"id\", user.getId());\n        subjectAttrs.put(\"department\", user.getDepartment());\n        subjectAttrs.put(\"level\", user.getLevel());\n        subjectAttrs.put(\"roles\", user.getRoles());\n        context.setSubject(subjectAttrs);\n\n        // 解析资源属性\n        Resource resource = resourceService.findById(resourceId);\n        Map<String, Object> resourceAttrs = new HashMap<>();\n        resourceAttrs.put(\"id\", resource.getId());\n        resourceAttrs.put(\"owner\", resource.getOwnerId());\n        resourceAttrs.put(\"department\", resource.getDepartment());\n        resourceAttrs.put(\"sensitivity\", resource.getSensitivity());\n        resourceAttrs.put(\"createTime\", resource.getCreateTime());\n        context.setResource(resourceAttrs);\n\n        // 解析操作属性\n        Map<String, Object> actionAttrs = new HashMap<>();\n        actionAttrs.put(\"type\", action);\n        context.setAction(actionAttrs);\n\n        // 解析环境属性\n        Map<String, Object> envAttrs = new HashMap<>();\n        envAttrs.put(\"time\", new Date());\n        envAttrs.put(\"ip\", getClientIp());\n        envAttrs.put(\"location\", getLocation());\n        context.setEnvironment(envAttrs);\n\n        return context;\n    }\n\n    private String getClientIp() {\n        HttpServletRequest request =\n            ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes())\n                .getRequest();\n\n        String ip = request.getHeader(\"X-Forwarded-For\");\n        if (ip == null || ip.isEmpty()) {\n            ip = request.getRemoteAddr();\n        }\n        return ip;\n    }\n}\n```\n\n### ABAC与Spring Security集成\n\n```java\n@Component\npublic class AbacPermissionEvaluator implements PermissionEvaluator {\n\n    @Autowired\n    private AbacEngine abacEngine;\n\n    @Autowired\n    private AttributeResolver attributeResolver;\n\n    @Override\n    public boolean hasPermission(Authentication authentication,\n                                Object targetDomainObject,\n                                Object permission) {\n        if (authentication == null || targetDomainObject == null) {\n            return false;\n        }\n\n        Long userId = ((CustomUserDetails) authentication.getPrincipal()).getUserId();\n        Long resourceId = extractResourceId(targetDomainObject);\n        String action = permission.toString();\n\n        AbacContext context = attributeResolver.buildContext(userId, resourceId, action);\n        return abacEngine.evaluate(context);\n    }\n\n    @Override\n    public boolean hasPermission(Authentication authentication,\n                                Serializable targetId,\n                                String targetType,\n                                Object permission) {\n        // 实现基于ID的权限检查\n        Long userId = ((CustomUserDetails) authentication.getPrincipal()).getUserId();\n        Long resourceId = Long.valueOf(targetId.toString());\n        String action = permission.toString();\n\n        AbacContext context = attributeResolver.buildContext(userId, resourceId, action);\n        return abacEngine.evaluate(context);\n    }\n\n    private Long extractResourceId(Object targetDomainObject) {\n        if (targetDomainObject instanceof BaseEntity) {\n            return ((BaseEntity) targetDomainObject).getId();\n        }\n        throw new IllegalArgumentException(\"无法提取资源ID\");\n    }\n}\n```\n\n## SpEL权限验证\n\nSpring Expression Language (SpEL) 提供了强大的表达式支持，可以实现灵活的权限控制。\n\n### 基础SpEL权限注解\n\nSpring Security提供的权限注解：\n\n```java\n@RestController\n@RequestMapping(\"/api/admin\")\npublic class AdminController {\n\n    // 需要ADMIN角色\n    @PreAuthorize(\"hasRole('ADMIN')\")\n    @GetMapping(\"/users\")\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n\n    // 需要特定权限\n    @PreAuthorize(\"hasAuthority('user:read')\")\n    @GetMapping(\"/users/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id);\n    }\n\n    // 多个角色之一\n    @PreAuthorize(\"hasAnyRole('ADMIN', 'MANAGER')\")\n    @PostMapping(\"/users\")\n    public User createUser(@RequestBody UserDto dto) {\n        return userService.create(dto);\n    }\n\n    // 组合条件\n    @PreAuthorize(\"hasRole('ADMIN') and hasAuthority('user:delete')\")\n    @DeleteMapping(\"/users/{id}\")\n    public void deleteUser(@PathVariable Long id) {\n        userService.delete(id);\n    }\n}\n```\n\n### 方法参数权限校验\n\n```java\n@Service\npublic class DocumentService {\n\n    // 检查是否为文档所有者\n    @PreAuthorize(\"#document.owner == authentication.principal.username\")\n    public void updateDocument(Document document) {\n        // 更新文档\n    }\n\n    // 使用方法参数\n    @PreAuthorize(\"#userId == authentication.principal.id\")\n    public List<Order> getUserOrders(Long userId) {\n        return orderRepository.findByUserId(userId);\n    }\n\n    // 复杂表达式\n    @PreAuthorize(\"hasRole('ADMIN') or (#project.managerId == authentication.principal.id)\")\n    public void updateProject(Project project) {\n        // 更新项目\n    }\n\n    // 调用其他Bean的方法\n    @PreAuthorize(\"@securityService.isOwner(authentication, #resourceId)\")\n    public void deleteResource(Long resourceId) {\n        resourceRepository.deleteById(resourceId);\n    }\n}\n```\n\n### 返回值权限过滤\n\n```java\n@Service\npublic class DataService {\n\n    // 过滤返回结果\n    @PostAuthorize(\"returnObject.owner == authentication.name\")\n    public Document getDocument(Long id) {\n        return documentRepository.findById(id).orElse(null);\n    }\n\n    // 过滤集合\n    @PostFilter(\"filterObject.department == authentication.principal.department\")\n    public List<Employee> getEmployees() {\n        return employeeRepository.findAll();\n    }\n\n    // 预过滤参数\n    @PreFilter(\"filterObject.owner == authentication.name\")\n    public void batchDelete(List<Document> documents) {\n        documents.forEach(doc -> documentRepository.delete(doc));\n    }\n}\n```\n\n### 自定义SpEL函数\n\n创建自定义权限评估器：\n\n```java\n@Component(\"customSecurity\")\npublic class CustomSecurityExpressions {\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private DepartmentService departmentService;\n\n    // 检查是否为部门经理\n    public boolean isDepartmentManager(Authentication auth, Long departmentId) {\n        if (auth == null || !auth.isAuthenticated()) {\n            return false;\n        }\n\n        CustomUserDetails userDetails = (CustomUserDetails) auth.getPrincipal();\n        Department dept = departmentService.findById(departmentId);\n\n        return dept != null && dept.getManagerId().equals(userDetails.getUserId());\n    }\n\n    // 检查是否在同一部门\n    public boolean inSameDepartment(Authentication auth, Long userId) {\n        CustomUserDetails currentUser = (CustomUserDetails) auth.getPrincipal();\n        User targetUser = userService.findById(userId);\n\n        return currentUser.getDepartmentId().equals(targetUser.getDepartmentId());\n    }\n\n    // 检查时间范围\n    public boolean withinBusinessHours() {\n        LocalTime now = LocalTime.now();\n        return now.isAfter(LocalTime.of(9, 0)) &&\n               now.isBefore(LocalTime.of(18, 0));\n    }\n\n    // 检查IP白名单\n    public boolean isAllowedIp(HttpServletRequest request) {\n        String clientIp = request.getRemoteAddr();\n        List<String> whitelist = Arrays.asList(\"192.168.1.0/24\", \"10.0.0.0/8\");\n\n        return whitelist.stream().anyMatch(range -> isIpInRange(clientIp, range));\n    }\n}\n```\n\n使用自定义函数：\n\n```java\n@RestController\n@RequestMapping(\"/api/departments\")\npublic class DepartmentController {\n\n    @PreAuthorize(\"@customSecurity.isDepartmentManager(authentication, #deptId)\")\n    @PutMapping(\"/{deptId}\")\n    public Department updateDepartment(@PathVariable Long deptId,\n                                      @RequestBody DepartmentDto dto) {\n        return departmentService.update(deptId, dto);\n    }\n\n    @PreAuthorize(\"@customSecurity.inSameDepartment(authentication, #userId)\")\n    @GetMapping(\"/colleagues/{userId}\")\n    public UserProfile getColleagueProfile(@PathVariable Long userId) {\n        return userService.getProfile(userId);\n    }\n\n    @PreAuthorize(\"@customSecurity.withinBusinessHours()\")\n    @PostMapping(\"/reports\")\n    public Report generateReport(@RequestBody ReportRequest request) {\n        return reportService.generate(request);\n    }\n}\n```\n\n### 动态权限表达式\n\n```java\n@Service\npublic class DynamicPermissionService {\n\n    @Autowired\n    private PermissionRuleRepository ruleRepository;\n\n    private final ExpressionParser parser = new SpelExpressionParser();\n\n    public boolean evaluate(String resource, String action, Authentication auth) {\n        // 从数据库获取权限规则\n        PermissionRule rule = ruleRepository.findByResourceAndAction(resource, action);\n        if (rule == null || !rule.isEnabled()) {\n            return false;\n        }\n\n        // 构建评估上下文\n        StandardEvaluationContext context = new StandardEvaluationContext();\n        context.setVariable(\"auth\", auth);\n        context.setVariable(\"principal\", auth.getPrincipal());\n        context.setRootObject(auth);\n\n        // 注册自定义函数\n        registerCustomFunctions(context);\n\n        try {\n            // 评估SpEL表达式\n            Expression expression = parser.parseExpression(rule.getExpression());\n            return expression.getValue(context, Boolean.class);\n        } catch (Exception e) {\n            log.error(\"权限表达式评估失败: {}\", rule.getExpression(), e);\n            return false;\n        }\n    }\n\n    private void registerCustomFunctions(StandardEvaluationContext context) {\n        try {\n            context.registerFunction(\"hasIpRange\",\n                CustomSecurityExpressions.class.getMethod(\"isAllowedIp\", HttpServletRequest.class));\n            context.registerFunction(\"isManager\",\n                CustomSecurityExpressions.class.getMethod(\"isDepartmentManager\", Authentication.class, Long.class));\n        } catch (NoSuchMethodException e) {\n            log.error(\"注册自定义函数失败\", e);\n        }\n    }\n}\n```\n\n### 方法级安全配置\n\n```java\n@Configuration\n@EnableGlobalMethodSecurity(\n    prePostEnabled = true,  // 启用@PreAuthorize和@PostAuthorize\n    securedEnabled = true,  // 启用@Secured\n    jsr250Enabled = true    // 启用@RolesAllowed\n)\npublic class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {\n\n    @Autowired\n    private AbacPermissionEvaluator abacPermissionEvaluator;\n\n    @Override\n    protected MethodSecurityExpressionHandler createExpressionHandler() {\n        DefaultMethodSecurityExpressionHandler handler =\n            new DefaultMethodSecurityExpressionHandler();\n\n        // 设置自定义权限评估器\n        handler.setPermissionEvaluator(abacPermissionEvaluator);\n\n        return handler;\n    }\n}\n```\n\n## 综合应用示例\n\n结合RBAC、ABAC和SpEL的完整权限系统：\n\n```java\n@Service\npublic class HybridAuthorizationService {\n\n    @Autowired\n    private RbacService rbacService;\n\n    @Autowired\n    private AbacEngine abacEngine;\n\n    @Autowired\n    private DynamicPermissionService dynamicPermissionService;\n\n    // 综合权限检查\n    public boolean authorize(AuthorizationRequest request) {\n        Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n\n        // 1. 首先检查RBAC基础权限\n        if (!rbacService.hasPermission(request.getUserId(),\n                                       request.getResource(),\n                                       request.getAction())) {\n            log.debug(\"RBAC权限检查失败\");\n            return false;\n        }\n\n        // 2. 然后进行ABAC细粒度控制\n        AbacContext context = buildAbacContext(request);\n        if (!abacEngine.evaluate(context)) {\n            log.debug(\"ABAC权限检查失败\");\n            return false;\n        }\n\n        // 3. 最后检查动态SpEL规则\n        if (!dynamicPermissionService.evaluate(request.getResource(),\n                                              request.getAction(),\n                                              auth)) {\n            log.debug(\"动态权限检查失败\");\n            return false;\n        }\n\n        log.info(\"权限检查通过: user={}, resource={}, action={}\",\n                request.getUserId(), request.getResource(), request.getAction());\n        return true;\n    }\n\n    // 带缓存的权限检查\n    @Cacheable(value = \"permissions\",\n               key = \"#request.userId + ':' + #request.resource + ':' + #request.action\")\n    public boolean authorizeWithCache(AuthorizationRequest request) {\n        return authorize(request);\n    }\n}\n\n@RestController\n@RequestMapping(\"/api/secure\")\npublic class SecureResourceController {\n\n    @Autowired\n    private HybridAuthorizationService authService;\n\n    @GetMapping(\"/resource/{id}\")\n    public ResponseEntity<?> getResource(@PathVariable Long id) {\n        AuthorizationRequest request = AuthorizationRequest.builder()\n            .userId(getCurrentUserId())\n            .resource(\"secure_resource\")\n            .action(\"read\")\n            .resourceId(id)\n            .build();\n\n        if (!authService.authorize(request)) {\n            return ResponseEntity.status(HttpStatus.FORBIDDEN)\n                .body(\"Access denied\");\n        }\n\n        return ResponseEntity.ok(resourceService.findById(id));\n    }\n}\n```\n"}]
